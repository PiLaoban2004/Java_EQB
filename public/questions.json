[
  {
    "id": 1,
    "type": "multiple",
    "question": "根据笔记内容，关于Java集合（Collection）与数组（Array）的对比，以下哪些说法是正确的？",
    "options": [
      "数组的长度是不可变的，而集合的长度是可变的。",
      "数组可以存储基本数据类型和引用数据类型，而集合只能存储引用数据类型。",
      "当处理一组数量在运行时可能动态变化的数据时，集合是比数组更好的选择。",
      "集合的底层数据结构只能是链表或哈希表，而数组是连续的内存空间。"
    ],
    "answer": [
      "数组的长度是不可变的，而集合的长度是可变的。",
      "数组可以存储基本数据类型和引用数据类型，而集合只能存储引用数据类型。",
      "当处理一组数量在运行时可能动态变化的数据时，集合是比数组更好的选择。"
    ],
    "score": 3,
    "explanation": "这是集合与数组最核心的区别。集合的底层数据结构是多样的，包括数组（如ArrayList）、链表（如LinkedList）、哈希表（如HashSet）、红黑树（如TreeSet）等，所以选项D是错误的。"
  },
  {
    "id": 2,
    "type": "single",
    "question": "在Java集合框架中，哪一个顶层接口用于表示键值对（Key-Value Pair）的集合？",
    "options": ["Collection", "List", "Set", "Map"],
    "answer": "Map",
    "score": 1,
    "explanation": "笔记中明确指出，Java集合框架分为两大顶层接口：`Collection`用于处理独立的、单个的元素；`Map`用于处理键值对数据。"
  },
  {
    "id": 3,
    "type": "short_answer",
    "question": "请简述`List`和`Set`接口在核心特性上的主要区别。",
    "answer": "`List`接口的特点是元素有序（按插入顺序存储）且可重复。`Set`接口的特点是元素通常无序（不保证插入顺序）且不可重复。",
    "score": 2.5,
    "explanation": "这是对`Collection`两大核心子接口基本特征的考察，理解它们的区别是选择正确集合类的第一步。"
  },
  {
    "id": 4,
    "type": "single",
    "question": "在何种业务场景下，使用`LinkedList`会比`ArrayList`具有明显的性能优势？",
    "options": [
      "需要频繁地根据索引随机访问集合中的元素。",
      "集合中绝大多数操作是遍历元素。",
      "需要频繁地在列表的头部和尾部进行插入和删除操作。",
      "集合创建后，元素数量固定不变，主要用于存储和读取。"
    ],
    "answer": "需要频繁地在列表的头部和尾部进行插入和删除操作。",
    "score": 3,
    "explanation": "根据笔记中的选型总结，`LinkedList`的底层是双向链表，对头尾节点的操作时间复杂度为O(1)，远优于`ArrayList`的O(n)。而随机访问是`ArrayList`的强项（O(1)）。"
  },
  {
    "id": 5,
    "type": "multiple",
    "question": "关于`ArrayList`的底层实现和特性，以下哪些说法是正确的？",
    "options": [
      "它的底层数据结构是动态数组。",
      "通过索引`get(index)`访问元素的时间复杂度为O(1)。",
      "在列表的中间位置插入或删除元素，其时间复杂度通常为O(n)。",
      "当容量不足时，`ArrayList`会自动扩容，创建一个更大的新数组并复制所有旧元素。"
    ],
    "answer": [
      "它的底层数据结构是动态数组。",
      "通过索引`get(index)`访问元素的时间复杂度为O(1)。",
      "在列表的中间位置插入或删除元素，其时间复杂度通常为O(n)。",
      "当容量不足时，`ArrayList`会自动扩容，创建一个更大的新数组并复制所有旧元素。"
    ],
    "score": 4,
    "explanation": "这四个选项全面地概括了`ArrayList`的核心工作原理和性能特点，这些都是Java开发中必须掌握的基础知识。"
  },
  {
    "id": 6,
    "type": "short_answer",
    "question": "为什么在创建 `ArrayList` 时，推荐指定一个预估的初始容量（如 `new ArrayList(100)`）？这样做有什么好处？",
    "answer": "推荐指定初始容量是为了性能优化。如果预先知道大致的数据量，指定初始容量可以避免或减少`ArrayList`在添加元素过程中因超出容量而触发的多次“扩容”操作。因为每次扩容都需要创建新数组并复制旧数组的全部元素，这是一个耗时的过程。",
    "score": 3,
    "explanation": "这是一个重要的性能优化技巧。在能预估数据量的场景下（例如，从数据库一次性查询N条记录放入List），指定初始容量是专业开发者的习惯。"
  },
  {
    "id": 7,
    "type": "code",
    "question": "请使用 `LinkedList` 的特有API，模拟一个栈（Stack）的入栈（push）和出栈（pop）操作。",
    "code_prompt": "LinkedList<String> stack = new LinkedList<>();",
    "answer": "// 入栈 \nstack.push(\"element1\"); \n// 或者 \nstack.addFirst(\"element1\"); \n\n// 出栈 \nString element = stack.pop(); \n// 或者 \nString element = stack.removeFirst();",
    "score": 3.5,
    "explanation": "笔记中提到`LinkedList`实现了`Deque`接口，因此提供了`push`和`pop`等方法，可以方便地作为栈使用。这考察了对`LinkedList`作为双端队列/栈使用的熟悉程度。"
  },
  {
    "id": 8,
    "type": "single",
    "question": "引入泛型（Generics）最主要的目标是什么？",
    "options": [
      "提升集合的运行效率。",
      "减少代码量。",
      "将类型检查从运行时提前到编译时，以提供类型安全。",
      "实现集合的多态性，让 `List<Dog>` 成为 `List<Animal>` 的子类。"
    ],
    "answer": "将类型检查从运行时提前到编译时，以提供类型安全。",
    "score": 2,
    "explanation": "泛型的核心价值在于类型安全。它允许编译器在编译阶段就发现类型不匹配的错误，避免了在运行时可能出现的`ClassCastException`，并免去了繁琐的手动类型转换。"
  },
  {
    "id": 9,
    "type": "short_answer",
    "question": "根据笔记，请解释为什么`List<User>`不是`List<Person>`的子类型，即使`User`是`Person`的子类？这个特性叫什么？",
    "answer": "这个特性叫做“泛型不具有多态性”。`List<User>`和`List<Person>`是两种完全不同的类型，它们之间没有继承关系。如果允许这种赋值（`List<Person> pList = new ArrayList<User>()`），那么之后就可以通过`pList.add(new Animal())`向一个本应只存放`User`的集合中添加其他类型的对象，这将破坏泛型的类型安全保证。",
    "score": 3.5,
    "explanation": "这是一个泛型中非常重要且容易混淆的概念。理解这一点对于正确使用泛型和理解泛型通配符（如`? extends Person`）至关重要。"
  },
  {
    "id": 10,
    "type": "multiple",
    "question": "要确保一个自定义类的对象能够在`HashSet`中正确地实现唯一性（即内容相同的对象被视为同一个），必须采取哪些措施？",
    "options": [
      "该类必须实现`Serializable`接口。",
      "该类必须重写`equals()`方法，定义对象内容相等的逻辑。",
      "该类必须重写`hashCode()`方法，并保证`equals()`为`true`的两个对象其`hashCode()`返回值也必须相等。",
      "该类必须实现`Comparable`接口。"
    ],
    "answer": [
      "该类必须重写`equals()`方法，定义对象内容相等的逻辑。",
      "该类必须重写`hashCode()`方法，并保证`equals()`为`true`的两个对象其`hashCode()`返回值也必须相等。"
    ],
    "score": 4,
    "explanation": "`HashSet`的唯一性判断依赖于`hashCode()`和`equals()`这两个方法。`hashCode()`用于快速定位存储位置，`equals()`用于在哈希冲突时进行精确比较。两者必须同时被正确重写，否则会导致集合行为异常。"
  },
  {
    "id": 11,
    "type": "short_answer",
    "question": "请简述当向一个`HashSet`中`add(element)`一个新元素时，其内部的详细工作流程。",
    "answer": "1. 首先调用`element`的`hashCode()`方法计算哈希码，通过哈希算法定位到底层`HashMap`中的一个桶（bucket）位置。\n2. 如果该桶为空，直接将元素存入，添加成功。\n3. 如果该桶不为空（发生哈希冲突），则遍历桶中的所有现有元素。\n4. 使用新元素`element`的`equals()`方法与桶内每个现有元素进行比较。\n5. 如果有任何一次`equals()`比较返回`true`，则认为元素已存在，添加失败。\n6. 如果遍历完所有元素，`equals()`都返回`false`，则将新元素添加到这个桶中（通常是链表或红黑树的末尾），添加成功。",
    "score": 4.5,
    "explanation": "这个问题深入考察了`HashSet`唯一性保证的底层原理，是Java面试中关于集合部分的高频考点，体现了对数据结构实现的深入理解。"
  },
  {
    "id": 12,
    "type": "single",
    "question": "根据笔记，`HashSet`的底层是使用哪一个集合类来实现其功能的？",
    "options": ["ArrayList", "TreeMap", "LinkedList", "HashMap"],
    "answer": "HashMap",
    "score": 2,
    "explanation": "笔记中明确指出，`HashSet`内部持有一个`HashMap`实例。添加到`HashSet`中的元素实际上是作为`key`存储在内部的`HashMap`中，而`value`则是一个固定的占位对象。"
  },
  {
    "id": 13,
    "type": "multiple",
    "question": "关于`HashMap`和`Hashtable`的对比，下列说法正确的有哪些？",
    "options": [
      "`HashMap`是非线程安全的，而`Hashtable`是线程安全的。",
      "`HashMap`允许一个null键和多个null值，而`Hashtable`不允许任何null键或null值。",
      "在新代码中，如果需要线程安全的Map，应优先选择`Hashtable`而不是`ConcurrentHashMap`。",
      "`HashMap`和`Hashtable`的默认初始容量和扩容机制完全相同。"
    ],
    "answer": [
      "`HashMap`是非线程安全的，而`Hashtable`是线程安全的。",
      "`HashMap`允许一个null键和多个null值，而`Hashtable`不允许任何null键或null值。"
    ],
    "score": 3.5,
    "explanation": "`Hashtable`是遗留的线程安全类，性能较差，现代并发编程推荐使用`ConcurrentHashMap`。`HashMap`和`Hashtable`的初始容量和扩容策略也不同。因此C和D是错误的。"
  },
  {
    "id": 14,
    "type": "single",
    "question": "在遍历一个`Map`集合时，哪种遍历方式被认为是最高效的，为什么？",
    "options": [
      "遍历`keySet()`，因为key是唯一的。",
      "遍历`values()`，因为直接获取值最快。",
      "遍历`entrySet()`，因为它可以一次性获取到key和value。",
      "使用迭代器遍历`keySet()`，因为迭代器最标准。"
    ],
    "answer": "遍历`entrySet()`，因为它可以一次性获取到key和value。",
    "score": 3,
    "explanation": "遍历`keySet()`后，还需要通过`map.get(key)`再次查找`value`，这在`HashMap`中涉及到一次额外的哈希定位。而遍历`entrySet()`，每个`Map.Entry`对象已经包含了`key`和`value`，无需二次查找，因此效率最高。"
  },
  {
    "id": 15,
    "type": "code",
    "question": "请补全以下代码，使用推荐的方式（`entrySet`）遍历一个`HashMap`并打印其所有键值对。",
    "code_prompt": "Map<Integer, String> map = new HashMap<>();\nmap.put(1, \"Java\");\nmap.put(2, \"Python\");",
    "answer": "Map<Integer, String> map = new HashMap<>();\nmap.put(1, \"Java\");\nmap.put(2, \"Python\");\n\nSet<Map.Entry<Integer, String>> entries = map.entrySet();\nfor (Map.Entry<Integer, String> entry : entries) {\n    System.out.println(entry.getKey() + \" -> \" + entry.getValue());\n}",
    "score": 3.5,
    "explanation": "考察对`Map`最高效遍历方式`entrySet`的实际编码能力，这是日常开发中的常用代码片段。"
  },
  {
    "id": 16,
    "type": "short_answer",
    "question": "什么是`ConcurrentModificationException`？在什么情况下会发生？",
    "answer": "`ConcurrentModificationException`（并发修改异常）是一个运行时异常。它通常发生在使用迭代器（包括增强for循环）遍历一个集合的过程中，同时又通过集合自身的方法（如`list.add()`, `map.remove()`）对集合的结构进行了修改（添加或删除元素）。",
    "score": 3.5,
    "explanation": "理解这个异常的触发条件是避免在集合遍历中踩坑的关键。根本原因在于迭代器维护的状态（如`expectedModCount`）与集合的实际状态（`modCount`）不一致了。"
  },
  {
    "id": 17,
    "type": "code",
    "question": "以下代码在运行时会抛出异常。请修改它，使其能够在遍历`List`时安全地删除所有包含\"bad\"的字符串。",
    "code_prompt": "List<String> list = new ArrayList<>(Arrays.asList(\"good\", \"bad\", \"nice\", \"bad idea\"));\nfor (String s : list) {\n    if (s.contains(\"bad\")) {\n        list.remove(s); \n    }\n}",
    "answer": "List<String> list = new ArrayList<>(Arrays.asList(\"good\", \"bad\", \"nice\", \"bad idea\"));\nIterator<String> iterator = list.iterator();\nwhile (iterator.hasNext()) {\n    String s = iterator.next();\n    if (s.contains(\"bad\")) {\n        iterator.remove(); // 使用迭代器的remove方法\n    }\n}",
    "score": 4,
    "explanation": "此题是`ConcurrentModificationException`的经典场景。正确做法是使用迭代器自身的`remove()`方法进行删除，因为该方法会同步集合和迭代器两者的内部状态，从而避免异常。"
  },
    {
    "id": 18,
    "type": "multiple",
    "question": "关于`Queue`接口中的`add`、`offer`、`put`三个用于插入元素的方法，以下描述正确的有哪些？",
    "options": [
      "`add(e)`在队列已满时会抛出`IllegalStateException`异常。",
      "`offer(e)`在队列已满时会返回`false`，而不会抛出异常。",
      "`put(e)`是`BlockingQueue`特有的方法，在队列已满时会阻塞当前线程，直到队列有空间。",
      "在任何情况下，这三个方法的行为都是完全一样的。"
    ],
    "answer": [
      "`add(e)`在队列已满时会抛出`IllegalStateException`异常。",
      "`offer(e)`在队列已满时会返回`false`，而不会抛出异常。",
      "`put(e)`是`BlockingQueue`特有的方法，在队列已满时会阻塞当前线程，直到队列有空间。"
    ],
    "score": 4,
    "explanation": "Queue接口为增删查操作提供了三套API，分别应对不同场景。`add`系列是“暴力派”，失败就抛异常；`offer`系列是“温柔派”，失败返回特殊值；`put`/`take`系列是“阻塞派”，专为并发场景设计。理解它们的区别对于编写健壮的程序至关重要。"
  },
  {
    "id": 19,
    "type": "multiple",
    "question": "与`Queue`的插入方法类似，其移除元素的`remove()`、`poll()`、`take()`方法也有不同行为。以下描述正确的有哪些？",
    "options": [
      "`remove()`在队列为空时会抛出`NoSuchElementException`异常。",
      "`poll()`在队列为空时会返回`null`。",
      "`take()`在队列为空时会阻塞线程，直到队列中有元素可取。",
      "对于非阻塞队列，`remove()`和`poll()`是完全等价的。"
    ],
    "answer": [
      "`remove()`在队列为空时会抛出`NoSuchElementException`异常。",
      "`poll()`在队列为空时会返回`null`。",
      "`take()`在队列为空时会阻塞线程，直到队列中有元素可取。"
    ],
    "score": 4,
    "explanation": "这考察了`Queue`三套API中用于移除元素的方法。在实际开发中，尤其是在高并发或需要处理边界条件的系统中，通常会选择使用`poll()`或`take()`来避免程序因异常而中断。"
  },
  {
    "id": 20,
    "type": "single",
    "question": "假设你正在开发一个生产者-消费者模型，使用`ArrayBlockingQueue`作为共享缓冲区。当缓冲区已满时，你希望生产者线程暂停等待，而不是抛出异常或立即返回失败。你应该使用哪个方法来放入元素？",
    "options": ["add(e)", "offer(e)", "put(e)", "push(e)"],
    "answer": "put(e)",
    "score": 3,
    "explanation": "根据笔记中对`ArrayBlockingQueue`的描述，`put(e)`方法正是在队列满时提供阻塞功能的API，这完全符合生产者-消费者模型中生产者需要等待的场景。"
  },
    {
    "id": 21,
    "type": "code",
    "question": "请编写一个`Comparator`，用于对一个`List<String>`按字符串长度进行降序排序。如果长度相同，则按字典序升序排序。",
    "code_prompt": "List<String> list = new ArrayList<>(Arrays.asList(\"apple\", \"banana\", \"pear\", \"kiwi\"));",
    "answer": "list.sort((s1, s2) -> {\n    if (s1.length() != s2.length()) {\n        return s2.length() - s1.length(); // 长度降序\n    } else {\n        return s1.compareTo(s2); // 字典序升序\n    }\n});",
    "score": 4.5,
    "explanation": "本题考察了`Comparator`接口的灵活运用，涉及两个排序维度（主、次排序条件），是实际开发中常见的自定义排序场景。使用Lambda表达式是现代Java的推荐写法。"
  },
  {
    "id": 22,
    "type": "single",
    "question": "在使用`Arrays.binarySearch()`方法进行二分查找前，对目标数组有什么样的前置要求？",
    "options": [
      "数组必须是`String`类型。",
      "数组必须已经排好序。",
      "数组长度必须是2的幂。",
      "数组不能包含重复元素。"
    ],
    "answer": "数组必须已经排好序。",
    "score": 2.5,
    "explanation": "二分查找算法的有效性建立在数据有序的基础上。如果在一个未排序的数组上执行`binarySearch`，其结果是未定义的，可能会返回错误的位置或找不到存在的元素。"
  },
  {
    "id": 23,
    "type": "single",
    "question": "调用`Map.put(K key, V value)`方法时，如果`key`在Map中已经存在，会发生什么？",
    "options": [
      "操作失败，抛出异常。",
      "操作失败，返回`false`。",
      "旧的`value`被新的`value`覆盖，方法返回新的`value`。",
      "旧的`value`被新的`value`覆盖，方法返回被覆盖的旧`value`。"
    ],
    "answer": "旧的`value`被新的`value`覆盖，方法返回被覆盖的旧`value`。",
    "score": 2,
    "explanation": "这是`Map.put`方法的一个重要特性。返回旧值使得调用者可以知道之前该key关联的值是什么，方便进行一些如“更新并记录旧值”的逻辑。"
  },
  {
    "id": 24,
    "type": "short_answer",
    "question": "在使用增强for循环（for-each loop）遍历一个List时，其底层实际上是如何工作的？为什么它同样会受到`ConcurrentModificationException`的影响？",
    "answer": "增强for循环在底层实际上是依赖`Iterator`（迭代器）工作的。编译器会将增强for循环代码转换为等效的使用`iterator()`方法获取迭代器，然后循环调用`hasNext()`和`next()`的代码。因为它本质上就是在使用迭代器，所以当在循环体内部通过集合自身的方法修改集合时，同样会触发`ConcurrentModificationException`。",
    "score": 3,
    "explanation": "理解增强for循环的语法糖本质有助于更深刻地理解Java的迭代机制和并发修改异常的根源。"
  },
  {
    "id": 25,
    "type": "single",
   "question": "如果一个自定义类只重写了`equals()`方法，而没有重写`hashCode()`方法，并将其对象作为元素添加到`HashSet`中，可能会导致什么问题？",
    "options": [
      "编译错误。",
      "运行时抛出`IllegalStateException`。",
      "两个内容相等（`equals`返回`true`）的对象可能都会被成功添加到`HashSet`中。",
      "性能下降，但功能完全正常。"
    ],
    "answer": "两个内容相等（`equals`返回`true`）的对象可能都会被成功添加到`HashSet`中。",
    "score": 4,
    "explanation": "如果没有重写`hashCode()`，它将使用从`Object`类继承的默认实现，该实现通常基于内存地址生成哈希码。因此，两个内容相同但内存地址不同的对象会有不同的哈希码，`HashSet`会将它们定位到不同的桶中，从而都添加成功，违背了`Set`的唯一性原则。"
  },
  {
    "id": 26,
    "type": "single",
    "question": "根据`Comparator<T>`接口的`compare(T o1, T o2)`方法的约定，如果要实现升序排序，当`o1`应该排在`o2`前面时，该方法应该返回什么？",
    "options": ["正整数", "负整数", "零", "true"],
    "answer": "负整数",
    "score": 3,
    "explanation": "这是`Comparator`接口的核心约定：返回负数意味着第一个参数`o1`“小于”第二个参数`o2`，应该排在前面；返回正数相反；返回零表示两者相等。"
  },
  {
    "id": 27,
    "type": "multiple",
    "question": "`LinkedList`实现了哪些重要的接口（根据笔记内容）？",
    "options": ["List", "Map", "Set", "Deque"],
    "answer": ["List", "Deque"],
    "score": 2,
    "explanation": "笔记中明确指出 `LinkedList` 是 `List` 接口的实现，同时它也实现了 `Deque` (双端队列) 接口，这使得它既有列表的特性，也具备队列和栈的能力。"
  },
  {
    "id": 28,
    "type": "short_answer",
    "question": "请描述`ArrayList`和`LinkedList`在内存开销上的主要区别。",
    "answer": "`ArrayList`的内存开销相对较小。它只需要存储元素本身，以及一些额外的容量信息。其内存是连续的。`LinkedList`的内存开销较大，因为它的每个元素都包装在一个节点（Node）对象中，该节点除了存储元素数据外，还需额外存储指向前一个和后一个节点的引用（指针），这增加了额外的内存占用。",
    "score": 3,
    "explanation": "在处理大量数据且内存敏感的场景下，内存开销是选择集合实现时需要考虑的一个因素。"
  },
  {
    "id": 29,
    "type": "single",
    "question": "执行`new ArrayList()`后，此时`ArrayList`的内部数组容量是多少？",
    "options": ["10", "16", "0", "1"],
    "answer": "0",
    "score": 2.5,
    "explanation": "根据笔记，JDK 7及以后的版本，`new ArrayList()`会创建一个初始容量为0的空列表（内部数组是一个空数组）。在第一次调用`add`方法时，才会进行第一次扩容，通常是分配一个容量为10的数组。"
  },
  {
    "id": 30,
    "type": "single",
    "question": "`map.values()`方法返回的是什么类型？",
    "options": ["List<V>", "Set<V>", "Collection<V>", "V[]"],
    "answer": "Collection<V>",
    "score": 2,
    "explanation": "`map.values()`返回一个`Collection`视图，因为它只保证包含了map中所有的值，但不保证顺序或唯一性（不同的key可以映射到相同的value）。因此，使用最泛化的`Collection`类型是合适的。"
  },
  {
    "id": 31,
    "type": "short_answer",
    "question": "为什么说遍历Map的`entrySet()`是最高效的方式？请从`HashMap`的实现角度解释。",
    "answer": "因为`HashMap`的`entrySet()`返回的`Set`中，每个`Entry`对象已经包含了键和值。遍历时，可以直接从`Entry`对象中获取`key`和`value`。相比之下，遍历`keySet()`时，在循环体内部需要通过`map.get(key)`来获取`value`，这个`get`操作需要根据`key`的哈希值再次进行一次查找定位过程。因此，遍历`entrySet()`避免了这次重复的查找，效率更高。",
    "score": 4,
    "explanation": "此题要求从`HashMap`的实现细节来解释性能差异，考察对`HashMap`工作原理的理解深度。"
  },
  {
    "id": 32,
    "type": "single",
    "question": "一个`HashMap`实例中，可以存在多少个`null`作为`key`？",
    "options": ["0个", "1个", "无限个", "不确定，取决于JDK版本"],
    "answer": "1个",
    "score": 2,
    "explanation": "笔记中明确提到，`HashMap`允许`key`和`value`为`null`。由于`key`必须是唯一的，所以最多只能有一个`key`为`null`。而`value`可以有多个为`null`。"
  },
  {
    "id": 33,
    "type": "code",
    "question": "给定一个`ArrayList<Integer> list`，请使用`list.sort()`方法和Lambda表达式对其进行降序排序。",
    "code_prompt": "ArrayList<Integer> list = new ArrayList<>(Arrays.asList(3, 1, 4, 1, 5, 9));",
    "answer": "list.sort((o1, o2) -> o2 - o1);",
    "score": 3,
    "explanation": "考察使用Lambda表达式快速实现`Comparator`接口，这是Java 8以后推荐的简洁写法。`o2 - o1`是实现Integer降序排序的经典技巧。"
  },
  {
    "id": 34,
    "type": "multiple",
    "question": "以下关于`Iterator`迭代器的说法，哪些是正确的？",
    "options": [
      "`Iterator`是遍历集合的统一标准接口。",
      "调用`next()`方法会返回下一个元素，并且会自动将内部指针后移。",
      "在通过迭代器遍历集合时，可以使用迭代器自身的`remove()`方法安全地删除元素。",
      "所有的`Collection`实现类都必须实现`Iterator`接口。"
    ],
    "answer": [
      "`Iterator`是遍历集合的统一标准接口。",
      "调用`next()`方法会返回下一个元素，并且会自动将内部指针后移。",
      "在通过迭代器遍历集合时，可以使用迭代器自身的`remove()`方法安全地删除元素。"
    ],
    "score": 3.5,
    "explanation": "选项D是错误的。`Collection`的实现类并未直接实现`Iterator`接口，而是提供了一个`iterator()`方法来返回一个`Iterator`的实例。其他三项都是对`Iterator`核心功能和用法的正确描述。"
  },
  {
    "id": 35,
    "type": "single",
    "question": "如果`HashMap`的key是一个自定义对象，那么这个对象必须满足什么条件才能保证`HashMap`的正常工作？",
    "options": [
      "必须实现`Comparable`接口。",
      "必须是不可变对象（Immutable）。",
      "必须正确地重写`hashCode()`和`equals()`方法。",
      "必须有一个无参构造函数。"
    ],
    "answer": "必须正确地重写`hashCode()`和`equals()`方法。",
    "score": 3,
    "explanation": "与`HashSet`一样，`HashMap`通过key的`hashCode()`和`equals()`来定位和区分不同的条目。为了确保能够正确地存取键值对，这两个方法必须被正确重写。虽然将不可变对象用作key是最佳实践，但不是强制要求。"
  },
  {
    "id": 36,
    "type": "single",
    "question": "在Java中，如果一个方法需要接收一个`List`，这个`List`中可以存放`Integer`或任何`Integer`的父类型（如`Number`, `Object`），那么该方法的参数类型应该如何声明？",
    "options": [
      "`List<Number> list`",
      "`List<? extends Number> list`",
      "`List<? super Integer> list`",
      "`List<Object> list`"
    ],
    "answer": "`List<? super Integer> list`",
    "score": 4.5,
    "explanation": "这是一个关于泛型通配符的进阶问题，虽然笔记中没有直接讲授通配符，但是基于“泛型不具有多态性”的概念延伸而来。`? super Integer`表示一个未知类型，这个类型是`Integer`本身或者其任何父类型，符合题意。这考察了对泛型更深层次的理解（PECS原则：Producer-Extends, Consumer-Super）。"
  },
  {
    "id": 37,
    "type": "short_answer",
    "question": "请解释`ArrayList`的`remove(int index)`和`remove(Object o)`两个重载方法之间的区别和潜在的陷阱。",
    "answer": "`remove(int index)`是按索引删除，它会删除指定位置的元素并返回被删除的元素。`remove(Object o)`是按内容删除，它会删除集合中与对象`o`相等的第一个元素，并返回一个布尔值（`true`表示删除成功）。潜在的陷阱是当`ArrayList`中存储的是`Integer`类型时，如果调用`list.remove(10)`，编译器会优先匹配`remove(int index)`，意图是删除索引为10的元素，而不是内容为10的元素。如果想按内容删除，必须传递一个`Integer`对象，如`list.remove(Integer.valueOf(10))`。",
    "score": 4,
    "explanation": "这个问题考察了对`ArrayList` API细节的掌握，特别是在处理`Integer`集合时由于自动装箱/拆箱可能引发的歧义和错误，非常具有实践性。"
  },
  {
    "id": 38,
    "type": "single",
    "question": "`Queue`接口遵循的基本原则是什么？",
    "options": ["后进先出 (LIFO)", "先进先出 (FIFO)", "无序", "按优先级"],
    "answer": "先进先出 (FIFO)",
    "score": 1.5,
    "explanation": "笔记中明确定义，Queue (队列) 是一种遵循先进先出 (FIFO, First-In-First-Out) 原则的特殊线性表。"
  },
  {
    "id": 39,
    "type": "single",
    "question": "以下哪个操作在`LinkedList`上的时间复杂度是O(n)？",
    "options": [
      "`addFirst(e)`",
      "`removeLast()`",
      "`get(int index)`",
      "`add(e)` (即 addLast)"
    ],
    "answer": "`get(int index)`",
    "score": 2.5,
    "explanation": "`LinkedList`由于是链表结构，无法直接通过计算内存地址偏移来访问元素，随机访问`get(index)`需要从头或尾开始遍历，直到找到第index个节点，所以时间复杂度是O(n)。而头尾操作都是O(1)。"
  },
  {
    "id": 40,
    "type": "short_answer",
    "question": "`Iterator`的`remove()`方法为什么是安全的，而集合的`remove()`方法在迭代时会不安全？请从`modCount`的角度解释。",
    "answer": "集合内部有一个`modCount`变量，记录集合结构被修改的次数。当创建迭代器时，迭代器会保存一份当前集合的`modCount`值（称为`expectedModCount`）。在迭代过程中，如果通过集合自身的`remove()`方法修改了集合，只会增加集合的`modCount`，而迭代器的`expectedModCount`没有变。下一次迭代器操作（如`next()`）会检查到`modCount != expectedModCount`，于是抛出`ConcurrentModificationException`。\n而`Iterator.remove()`方法是安全的，因为它在内部删除元素的同时，会主动更新迭代器自身的`expectedModCount`使其与集合的`modCount`保持同步，所以不会触发异常。",
    "score": 4.5,
    "explanation": "这是对并发修改异常底层机制的深度考察，能回答这个问题说明对`Iterator`的工作原理有非常清晰的认识。"
  },
  {
    "id": 41,
    "type": "multiple",
    "question": "`java.util.Arrays`工具类提供了哪些常用功能？",
    "options": [
      "`toString(array)`: 将数组转换为字符串。",
      "`sort(array)`: 对数组进行排序。",
      "`binarySearch(array, key)`: 在有序数组中进行二分查找。",
      "`toList(array)`: 直接将任何数组高效转换为`ArrayList`。"
    ],
    "answer": [
      "`toString(array)`: 将数组转换为字符串。",
      "`sort(array)`: 对数组进行排序。",
      "`binarySearch(array, key)`: 在有序数组中进行二分查找。"
    ],
    "score": 3,
    "explanation": "`Arrays`类没有`toList()`方法。将数组转为List通常使用`Arrays.asList()`，但它返回的是一个内部类的`List`，该`List`长度固定，不支持`add`或`remove`操作。所以选项D描述不准确。"
  },
  {
    "id": 42,
    "type": "single",
    "question": "对于一个已经存储了1000个元素的`ArrayList`，在列表的起始位置（索引0）插入一个新元素，大约需要执行多少次元素移动操作？",
    "options": ["1次", "2次", "1000次", "不需要移动"],
    "answer": "1000次",
    "score": 3,
    "explanation": "在`ArrayList`的起始位置插入元素，为了给新元素腾出空间，原有的所有1000个元素都需要向后移动一位。这是一个典型的O(n)操作，n是集合的大小。"
  },
  {
    "id": 43,
    "type": "single",
    "question": "以下哪种集合实现类在迭代时能保证元素的顺序与其插入时的顺序一致？",
    "options": ["HashSet", "HashMap", "ArrayList", "TreeSet"],
    "answer": "ArrayList",
    "score": 2,
    "explanation": "`ArrayList`和`LinkedList`都属于`List`，保证了元素的插入顺序。`HashSet`和`HashMap`是无序的。`TreeSet`和`TreeMap`会根据元素的自然顺序或指定的`Comparator`进行排序，而不是插入顺序。（注：`LinkedHashSet`和`LinkedHashMap`可以保证插入顺序，但笔记未提及）"
  },
  {
    "id": 44,
    "type": "code",
    "question": "如果有一个`User`类，包含`id`和`name`属性。请重写其`equals()`方法，使得只有当`id`和`name`都相同时，两个`User`对象才被认为是相等的。",
    "code_prompt": "class User {\n    private int id;\n    private String name;\n\n    // constructor, getters, setters...\n\n    @Override\n    public boolean equals(Object obj) {\n        // Your code here\n    }\n}",
    "answer": "@Override\npublic boolean equals(Object obj) {\n    if (this == obj) return true;\n    if (obj == null || getClass() != obj.getClass()) return false;\n    User otherUser = (User) obj;\n    return this.id == otherUser.id && java.util.Objects.equals(this.name, otherUser.name);\n}",
    "score": 3.5,
    "explanation": "考察`equals`方法的标准写法，包括地址比较、null检查和类型检查等前置判断。使用`Objects.equals()`来处理`name`可能为null的情况，是更健壮的写法。"
  },
  {
    "id": 45,
    "type": "short_answer",
    "question": "泛型中的“类型擦除”（Type Erasure）是什么意思？它对Java的泛型实现意味着什么？",
    "answer": "类型擦除是指Java泛型信息只存在于代码的编译阶段，在生成的字节码中，所有的泛型类型参数都会被替换为它们的上界（如`T`被替换为`Object`，`T extends Number`被替换为`Number`），并插入必要的类型转换代码。这意味着，对于JVM来说，`ArrayList<String>`和`ArrayList<Integer>`在运行时是同一个类（`ArrayList.class`），它并不知道集合中元素的确切泛型类型。",
    "score": 4,
    "explanation": "虽然笔记中只提到了泛型是编译期机制，但理解类型擦除是深入理解泛型本质的关键。这个问题考察了对这一核心概念的认知。"
  },
  {
    "id": 46,
    "type": "single",
    "question": "当不再推荐使用`Hashtable`时，如果需要一个线程安全的`Map`实现，应该优先选择哪个类？",
    "options": ["Collections.synchronizedMap(new HashMap())", "ConcurrentHashMap", "TreeMap", "自己用`synchronized`关键字包装HashMap的所有方法"],
    "answer": "ConcurrentHashMap",
    "score": 3,
    "explanation": "笔记中提到，`ConcurrentHashMap`提供了比`Hashtable`更好的并发性能。`ConcurrentHashMap`使用了更先进的锁机制（如分段锁或CAS），在高并发场景下，其吞吐量远超于对整个`Map`进行同步的`Hashtable`或`Collections.synchronizedMap`。"
  },
  {
    "id": 47,
    "type": "multiple",
    "question": "以下关于`HashSet`的说法，哪些是正确的？",
    "options": [
      "它不允许存储重复的元素。",
      "它通常不保证元素的存储和取出顺序。",
      "它允许存储一个`null`元素。",
      "它的所有操作都是线程安全的。"
    ],
    "answer": [
      "它不允许存储重复的元素。",
      "它通常不保证元素的存储和取出顺序。",
      "它允许存储一个`null`元素。"
    ],
    "score": 3,
    "explanation": "`HashSet`的核心特性就是无序、唯一，并允许一个null。与`HashMap`一样，它本身是非线程安全的。需要线程安全的Set可以使用`Collections.synchronizedSet()`或`ConcurrentHashMap.newKeySet()`。"
  },
  {
    "id": 48,
    "type": "single",
    "question": "如果一个`ArrayList`的`remove(Object o)`方法被调用，它会如何查找要删除的元素？",
    "options": [
      "使用二分查找。",
      "通过哈希定位。",
      "从头到尾依次遍历，使用`equals()`方法进行比较。",
      "从尾到头依次遍历，使用`==`进行比较。"
    ],
    "answer": "从头到尾依次遍历，使用`equals()`方法进行比较。",
    "score": 2.5,
    "explanation": "`ArrayList`的`remove(Object o)`实现是线性搜索，它会从列表的第一个元素开始，逐个调用`equals()`方法进行匹配，直到找到第一个匹配的元素并删除它。因此其时间复杂度是O(n)。"
  },
  {
    "id": 49,
    "type": "short_answer",
    "question": "在Java中，为何推荐使用接口（如`List`、`Map`）作为变量声明类型或方法参数类型，而不是具体的实现类（如 `ArrayList`、`HashMap`）？",
    "answer": "这是面向接口编程的一种体现，主要有以下好处：\n1. **解耦和灵活性**：代码不依赖于具体的实现细节。未来如果发现`ArrayList`性能不佳，可以很方便地将其替换为`LinkedList`或其他`List`实现，而不需要修改大量使用该`List`的代码。\n2. **可扩展性**：使代码更加通用，可以接受任何符合该接口规范的实现类的对象。\n3. **符合设计原则**：符合“依赖倒置原则”，即应该依赖于抽象，而不是依赖于具体。",
    "score": 3.5,
    "explanation": "这是一个非常重要的编程实践问题，考察了对面向对象设计原则的理解。例如，声明 `List<String> users = new ArrayList<>();` 好于 `ArrayList<String> users = new ArrayList<>();`。"
  },
  {
    "id": 50,
    "type": "code",
    "question": "假设有一个`Map<String, Integer> map`，其中一个键为\"b\"。以下这段删除操作的代码有什么问题？应该如何修正？",
    "code_prompt": "for (String key : map.keySet()) {\n    if (\"b\".equals(key)) {\n        map.remove(\"b\");\n    }\n}",
    "answer": "问题：这段代码会在运行时抛出`ConcurrentModificationException`，因为在通过`keySet`的迭代器进行遍历时，使用了`map`自身的方法`remove`来修改集合结构。\n\n修正：应该使用迭代器自身的`remove`方法进行删除。\n\nIterator<String> iterator = map.keySet().iterator();\nwhile (iterator.hasNext()) {\n    String key = iterator.next();\n    if (\"b\".equals(key)) {\n        iterator.remove(); // 正确做法\n    }\n}",
    "score": 4,
    "explanation": "这是并发修改异常的又一个经典案例，这次是发生在`Map`的遍历中。它强化了“在迭代过程中必须使用迭代器自己的方法来修改集合”这一黄金法则。"
  },
  {
    "id": 51,
    "type": "single",
    "question": "根据笔记，Java I/O将复杂的数据交换过程抽象为一种统一的模型，这个模型是什么？",
    "options": ["File", "Buffer", "Channel", "Stream"],
    "answer": "Stream",
    "score": 1.5,
    "explanation": "笔记开篇即明确指出，Java I/O的核心思想是将数据交换抽象为“流 (Stream)”，它是一种抽象的数据通道。"
  },
  {
    "id": 52,
    "type": "single",
    "question": "关于`java.io.File`类，以下哪个描述是最准确的？",
    "options": [
      "一个`File`对象包含了其所指向文件的实际数据内容。",
      "创建一个`new File(\"test.txt\")`对象会立即在磁盘上创建一个物理文件。",
      "`File`类是文件和目录路径名的抽象表示，是操作文件系统的入口。",
      "读写文件内容是`File`类的核心功能。"
    ],
    "answer": "`File`类是文件和目录路径名的抽象表示，是操作文件系统的入口。",
    "score": 2.5,
    "explanation": "笔记中重点强调了`File`类不等于文件内容，它仅仅是一个路径的代表。要读写内容，必须使用I/O流。创建`File`对象并不会创建物理文件，需要调用`createNewFile()`方法。"
  },
  {
    "id": 53,
    "type": "short_answer",
    "question": "请简述字节流和字符流的核心区别，并说明在何种场景下应该优先选择字符流？",
    "answer": "核心区别在于处理的数据单元不同：字节流以字节（byte）为单位，可以处理任何类型的数据；字符流以字符（char）为单位，专为处理文本数据设计。当需要处理纯文本文件（如.txt, .java, .properties, .xml）时，应该优先选择字符流，因为它可以自动处理字符编码，有效防止乱码问题。",
    "score": 3.5,
    "explanation": "这是对I/O流两大分支的根本性考察，理解它们的适用场景是正确使用Java I/O的基础。"
  },
  {
    "id": 54,
    "type": "single",
    "question": "从JDK 7开始，推荐使用`try-with-resources`语句来处理I/O流。其最主要的好处是什么？",
    "options": [
      "它能显著提高文件读写的性能。",
      "它能自动捕获并处理所有的`IOException`。",
      "它能保证流资源被自动、正确地关闭，无论是否发生异常，从而避免资源泄漏。",
      "它允许在单个`try`块中并发地读写多个文件。"
    ],
    "answer": "它能保证流资源被自动、正确地关闭，无论是否发生异常，从而避免资源泄漏。",
    "score": 3,
    "explanation": "笔记中明确指出，`try-with-resources`的核心价值在于自动资源管理，它极大地简化了代码并提高了程序的健壮性，避免了在复杂的`finally`块中手动关闭资源的麻烦和潜在错误。"
  },
  {
    "id": 55,
    "type": "short_answer",
    "question": "在使用字节数组作为缓冲区复制文件时，`out.write(buffer)`和`out.write(buffer, 0, len)`这两个写操作有何关键区别？为什么必须使用后者？",
    "answer": "关键区别在于写入的数据量。`out.write(buffer)`会写入整个缓冲区数组的内容，而`out.write(buffer, 0, len)`只写入缓冲区中从索引0开始的`len`个字节。必须使用后者是因为，在最后一次读取文件时，读入缓冲区的数据量（`len`）很可能小于缓冲区的总大小。如果此时仍使用`out.write(buffer)`，会将缓冲区中上一次读取后残留的“脏数据”也一并写入目标文件，导致文件末尾数据损坏。",
    "score": 4.5,
    "explanation": "这是一个非常深入且极具实践意义的问题，考察了对缓冲读写细节的深刻理解，是衡量开发者是否真正掌握文件I/O操作的标志性问题。"
  },
  {
    "id": 56,
    "type": "multiple",
    "question": "一个Java类的对象要想被成功序列化，必须满足以下哪些条件？",
    "options": [
      "该类必须实现`java.io.Serializable`接口。",
      "该类中所有非瞬态（non-transient）的成员变量也必须是可序列化的。",
      "该类必须提供一个公开的无参构造函数。",
      "该类的所有方法都必须是`public`的。"
    ],
    "answer": [
      "该类必须实现`java.io.Serializable`接口。",
      "该类中所有非瞬态（non-transient）的成员变量也必须是可序列化的。"
    ],
    "score": 4,
    "explanation": "序列化的基本要求是实现`Serializable`接口。此外，序列化是递归的，如果一个对象包含其他对象，这些被包含的对象（除非被`transient`修饰）也必须是可序列化的。无参构造函数是某些反序列化场景（如`Externalizable`）或框架的要求，但不是`Serializable`的强制要求。"
  },
  {
    "id": 57,
    "type": "single",
    "question": "在使用`BufferedReader`的`readLine()`方法读取文本文件时，该方法如何表示已到达文件末尾？",
    "options": ["返回-1", "返回一个空字符串(\"\")", "抛出`EOFException`", "返回`null`"],
    "answer": "返回`null`",
    "score": 2,
    "explanation": "笔记中的代码示例明确展示了`while ((line = reader.readLine()) != null)`的用法，这说明`readLine()`在读完所有行后会返回`null`。这与字节流的`read()`方法返回-1是不同的，需要区分记忆。"
  },
  {
    "id": 58,
    "type": "code",
    "question": "请补全代码，使用`try-with-resources`语句和缓冲流，实现一个将`source.txt`内容逐行复制到`dest.txt`的功能。",
    "code_prompt": "try (/* ... */) {\n    // ...\n} catch (IOException e) {\n    e.printStackTrace();\n}",
    "answer": "try (\n    BufferedReader reader = new BufferedReader(new FileReader(\"source.txt\"));\n    BufferedWriter writer = new BufferedWriter(new FileWriter(\"dest.txt\"))\n) {\n    String line;\n    while ((line = reader.readLine()) != null) {\n        writer.write(line);\n        writer.newLine(); // 写入换行符\n    }\n} catch (IOException e) {\n    e.printStackTrace();\n}",
    "score": 4,
    "explanation": "此题考察了字符缓冲流（`BufferedReader`, `BufferedWriter`）的典型用法，以及`try-with-resources`的正确格式。注意`readLine()`读取的内容不包含换行符，需要用`newLine()`或`write(\"\\n\")`手动添加。"
  },
  {
    "id": 59,
    "type": "single",
    "question": "如果你需要创建一个可能包含多级不存在父目录的目录结构，例如 `data/logs/app`，应该使用`File`类的哪个方法？",
    "options": ["create()", "mkdir()", "mkdirs()", "createNewFile()"],
    "answer": "mkdirs()",
    "score": 2.5,
    "explanation": "根据笔记API表格，`mkdir()`只能创建单级目录（父目录必须存在），而`mkdirs()`可以创建此路径对应的所有不存在的父目录，符合题意。"
  },
  {
    "id": 60,
    "type": "short_answer",
    "question": "在Java I/O中，`new BufferedInputStream(new FileInputStream(\"a.bin\"))`这种代码结构体现了哪种设计模式？请解释各个角色的对应关系。",
    "answer": "这种结构体现了**装饰器模式 (Decorator Pattern)**。\n- **抽象组件 (Component)**: `InputStream` 抽象类。\n- **具体组件 (Concrete Component)**: `FileInputStream`，它是被装饰的原始对象，负责与物理文件直接交互。\n- **装饰器 (Decorator)**: `BufferedInputStream`，它包装（装饰）了一个`InputStream`对象，并为其增加了缓冲功能以提升性能，同时它也继承自`InputStream`，保持了接口的统一。",
    "score": 4,
    "explanation": "将具体的I/O类库使用上升到设计模式的高度进行考察，体现了对软件设计原则的理解，属于中高难度题目。"
  },
  {
    "id": 61,
    "type": "multiple",
    "question": "以下哪些I/O相关的异常属于受检异常 (Checked Exception)？",
    "options": [
      "IOException",
      "FileNotFoundException",
      "NotSerializableException",
      "ArrayIndexOutOfBoundsException"
    ],
    "answer": ["IOException", "FileNotFoundException", "NotSerializableException"],
    "score": 3,
    "explanation": "`IOException`及其大部分子类（如`FileNotFoundException`, `NotSerializableException`）都属于受检异常，编译器会强制要求进行处理。而`ArrayIndexOutOfBoundsException`是`RuntimeException`的子类，属于非受检异常。"
  },
  {
    "id": 62,
    "type": "single",
    "question": "调用`File`对象的`delete()`方法试图删除一个目录时，什么情况下该操作会失败？",
    "options": [
      "目录是只读的。",
      "目录中包含了文件或子目录。",
      "程序没有管理员权限。",
      "以上所有情况都可能导致失败。"
    ],
    "answer": "以上所有情况都可能导致失败。",
    "score": 3,
    "explanation": "笔记中明确指出`delete()`只能删除**空**目录。此外，文件系统的权限（只读、操作系统权限）也是`delete`能否成功的现实因素。因此，这是一个综合性的考察。"
  },
  {
    "id": 63,
    "type": "code",
    "question": "请使用`File`类的API，编写代码来递归地删除一个非空目录及其所有内容。",
    "code_prompt": "public void deleteDirectory(File directory) {\n    // Your code here\n}",
    "answer": "public void deleteDirectory(File directory) {\n    File[] files = directory.listFiles();\n    if (files != null) {\n        for (File file : files) {\n            if (file.isDirectory()) {\n                deleteDirectory(file); // 递归删除子目录\n            } else {\n                file.delete(); // 删除子文件\n            }\n        }\n    }\n    directory.delete(); // 删除空目录本身\n}",
    "score": 4.5,
    "explanation": "这是一个经典的算法题，结合了`File`类的API（`listFiles`, `isDirectory`, `delete`）和递归思想，是面试中常见的文件操作考点。"
  },
  {
    "id": 64,
    "type": "short_answer",
    "question": "在进行对象反序列化时，除了`IOException`，为什么还必须捕获`ClassNotFoundException`？",
    "answer": "因为反序列化是将字节序列恢复为Java对象的过程，这个过程需要JVM根据字节流中的信息找到并加载对应的`.class`文件来构建对象。如果在当前的类路径（classpath）下找不到这个`.class`文件（例如，程序迁移后缺少了某个jar包，或者类名已更改），JVM就无法完成对象的重构，此时就会抛出`ClassNotFoundException`。",
    "score": 3.5,
    "explanation": "考察对反序列化底层机制的理解，即反序列化不仅仅是数据恢复，还依赖于运行时的类加载机制。"
  },
  {
    "id": 65,
    "type": "single",
    "question": "`FileInputStream`的`read()`方法返回一个`int`类型而不是`byte`类型，其主要目的是什么？",
    "options": [
      "为了兼容大于一个字节的宽字符。",
      "为了能够返回一个在合法字节值范围之外的特殊值（-1）来表示流的末尾。",
      "因为在早期的Java中，处理`int`比处理`byte`更快。",
      "这是一个历史遗留的API设计缺陷。"
    ],
    "answer": "为了能够返回一个在合法字节值范围之外的特殊值（-1）来表示流的末尾。",
    "score": 3,
    "explanation": "一个字节能表示的数值范围是0-255（无符号）。如果`read()`返回`byte`，那么任何返回值都可能是一个合法的数据字节，无法区分是数据还是结束信号。通过返回`int`，可以使用-1这个特殊值清晰地表示已到达流的末尾。"
  },
  {
    "id": 66,
    "type": "single",
    "question": "在处理I/O流时，`FileReader`、`FileInputStream` 这类流通常被称为“节点流”，而`BufferedReader`、`BufferedInputStream` 这类流被称为“处理流”。“节点流”最核心的特征是什么？",
    "options": [
      "它们性能最高。",
      "它们直接连接到具体的数据源或目的地（如文件、网络套接字）。",
      "它们内部自带缓冲区。",
      "它们只能处理字节数据。"
    ],
    "answer": "它们直接连接到具体的数据源或目的地（如文件、网络套接字）。",
    "score": 3.5,
    "explanation": "这是对I/O流装饰器模式中角色分工的理解。节点流是整个流链条的起点（输入）或终点（输出），是与物理设备直接打交道的“管道”，而处理流则是套在节点流之上的“增强设备”。"
  },
  {
    "id": 67,
    "type": "multiple",
    "question": "以下关于对象序列化的说法，哪些是正确的？",
    "options": [
      "序列化是将Java对象状态转换为字节序列的过程。",
      "只有实现了`Serializable`接口的类的对象才能被序列化。",
      "被`transient`关键字修饰的成员变量不会被序列化。",
      "静态（`static`）成员变量会被序列化到对象流中。"
    ],
    "answer": [
      "序列化是将Java对象状态转换为字节序列的过程。",
      "只有实现了`Serializable`接口的类的对象才能被序列化。",
      "被`transient`关键字修饰的成员变量不会被序列化。"
    ],
    "score": 4,
    "explanation": "选项D是错误的。序列化保存的是对象的状态（实例变量），而静态变量属于类级别，不属于任何特定对象的状态，因此不会被序列化。`transient`关键字的作用就是显式地排除某些实例变量，使其不参与序列化过程。"
  },
  {
    "id": 68,
    "type": "single",
    "question": "你正在编写一个程序，需要将一个包含多种数据类型（如`int`, `double`, `String`）的复杂对象持久化到磁盘。哪一对I/O流是完成此任务最直接和合适的选择？",
    "options": [
      "`FileWriter` 和 `FileReader`",
      "`FileOutputStream` 和 `FileInputStream`",
      "`ObjectOutputStream` 和 `ObjectInputStream`",
      "`PrintWriter` 和 `Scanner`"
    ],
    "answer": "`ObjectOutputStream` 和 `ObjectInputStream`",
    "score": 2.5,
    "explanation": "对象流（`ObjectOutputStream` / `ObjectInputStream`）是专门为序列化和反序列化整个Java对象而设计的，是处理复杂对象持久化的标准方式。"
  },
  {
    "id": 69,
    "type": "single",
    "question": "当`new FileOutputStream(file)`被成功调用后，如果`file`已经存在，将会发生什么？",
    "options": [
      "抛出`FileAlreadyExistsException`异常。",
      "在现有文件的末尾追加新内容。",
      "现有文件的内容将被清空（覆盖），准备写入新内容。",
      "询问用户是否要覆盖文件。"
    ],
    "answer": "现有文件的内容将被清空（覆盖），准备写入新内容。",
    "score": 3,
    "explanation": "`FileOutputStream`的这个构造函数默认以覆盖模式打开文件。如果希望追加内容，需要使用另一个构造函数 `new FileOutputStream(file, true)`。"
  },
  {
    "id": 70,
    "type": "short_answer",
    "question": "`Serializable`接口是一个没有任何方法的接口，它的作用是什么？这类接口在Java中被称为？",
    "answer": "这类接口被称为**标记接口 (Marker Interface)**。它的作用是向JVM提供一个元数据信息，即“标记”一个类的对象是“可以被序列化的”。JVM的序列化机制会在运行时检查一个对象所属的类是否实现了这个接口，以此来决定是否允许对其进行序列化操作。",
    "score": 3,
    "explanation": "考察对标记接口这一特殊设计模式的理解，以及`Serializable`接口在其中的具体作用。"
  },
  {
    "id": 71,
    "type": "multiple",
    "question": "调用`file.listFiles()`方法，在哪些情况下可能会返回`null`？",
    "options": [
      "当`file`对象代表的目录为空时。",
      "当`file`对象代表的路径不存在时。",
      "当`file`对象代表的路径是一个文件而不是一个目录时。",
      "当发生I/O错误（如权限不足）时。"
    ],
    "answer": [
      "当`file`对象代表的路径不存在时。",
      "当`file`对象代表的路径是一个文件而不是一个目录时。",
      "当发生I/O错误（如权限不足）时。"
    ],
    "score": 4,
    "explanation": "这是一个重要的API细节。当目录为空时，`listFiles()`会返回一个长度为0的空数组，而不是`null`。只有当`File`对象不代表一个有效的、可访问的目录时，才会返回`null`。"
  },
  {
    "id": 72,
    "type": "single",
    "question": "在性能方面，用`BufferedReader`包装`FileReader`，与用哪个类包装`FileInputStream`是出于同样的目的？",
    "options": [
      "`ObjectInputStream`",
      "`DataInputStream`",
      "`FilterInputStream`",
      "`BufferedInputStream`"
    ],
    "answer": "`BufferedInputStream`",
    "score": 2.5,
    "explanation": "`BufferedReader`为字符流提供缓冲，`BufferedInputStream`为字节流提供缓冲。它们的设计目的相同，都是通过减少对底层I/O设备的直接访问次数来提升读写性能，是装饰器模式在两个流体系中的平行应用。"
  },
  {
    "id": 73,
    "type": "short_answer",
    "question": "一个`User`类实现了`Serializable`接口，但你希望它的`password`字段不被序列化，应该如何操作？为什么通常要这样做？",
    "answer": "应该使用`transient`关键字修饰`password`字段，即 `private transient String password;`。通常这样做是出于**安全考虑**。密码、密钥等敏感信息不应该以明文形式持久化到文件或在网络上传输，以防止数据泄露后被恶意利用。将它们声明为`transient`可以有效避免其被包含在序列化的字节流中。",
    "score": 3.5,
    "explanation": "考察`transient`关键字的用法及应用场景，这在实际开发中处理敏感数据时非常重要。"
  },
  {
    "id": 74,
    "type": "single",
    "question": "当你需要向一个文本文件写入内容，并且希望代码在不同操作系统（如Windows和Linux）上都能正确生成换行，使用哪个类的哪个方法是最便捷和可移植的？",
    "options": [
      "`BufferedWriter`的`write(\"\\n\")`方法",
      "`FileWriter`的`write(System.lineSeparator())`方法",
      "`PrintWriter`的`println()`方法",
      "`FileOutputStream`的`write()`方法写入换行符的字节"
    ],
    "answer": "`PrintWriter`的`println()`方法",
    "score": 3,
    "explanation": "`PrintWriter.println()`方法会自动处理平台相关的行分隔符，提供了最佳的可移植性。其他选项虽然也能实现，但不如`println()`直接和方便。"
  },
  {
    "id": 75,
    "type": "multiple",
    "question": "以下哪些流属于字符流（Character Stream）？",
    "options": [
      "FileReader",
      "FileOutputStream",
      "PrintWriter",
      "BufferedInputStream"
    ],
    "answer": ["FileReader", "PrintWriter"],
    "score": 2,
    "explanation": "根据Java I/O的分类，以`Reader`或`Writer`结尾的类通常是字符流（如`FileReader`, `PrintWriter`）。以`InputStream`或`OutputStream`结尾的类是字节流（如`FileOutputStream`, `BufferedInputStream`）。"
  },
  {
    "id": 76,
    "type": "single",
    "question": "给定`File f = new File(\"../docs/report.pdf\");`，调用`f.getName()`会返回什么？",
    "options": ["../docs/report.pdf", "report.pdf", "docs/report.pdf", "../docs"],
    "answer": "report.pdf",
    "score": 2.5,
    "explanation": "`getName()`方法返回路径中最后一个名称分隔符之后的部分，即文件名或最内层的目录名，而不包括之前的路径信息。"
  },
  {
    "id": 77,
    "type": "code",
    "question": "假设一个文件`user.dat`中序列化存储了多个`User`对象。请补全代码，使用循环从文件中读取所有`User`对象，直到文件末尾。",
    "code_prompt": "List<User> users = new ArrayList<>();\ntry (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"user.dat\"))) {\n    // Your code here\n} catch (IOException | ClassNotFoundException e) {\n    e.printStackTrace();\n}",
    "answer": "List<User> users = new ArrayList<>();\ntry (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"user.dat\"))) {\n    while (true) {\n        try {\n            User user = (User) ois.readObject();\n            users.add(user);\n        } catch (EOFException e) {\n            // 到达文件末尾，正常退出循环\n            break;\n        }\n    }\n} catch (IOException | ClassNotFoundException e) {\n    e.printStackTrace();\n}",
    "score": 4.5,
    "explanation": "连续读取多个序列化对象的标准做法是使用一个无限循环，并在内部捕获`EOFException`（End Of File Exception），这个异常是`readObject()`在读到流末尾时抛出的，以此作为循环结束的标志。"
  },
  {
    "id": 78,
    "type": "single",
    "question": "在Java I/O的装饰器模式应用中，哪一类流是整个流“链条”的基础，直接与数据源（如文件）进行交互？",
    "options": ["节点流 (Node Stream)", "处理流 (Processing Stream)", "过滤流 (Filter Stream)", "对象流 (Object Stream)"],
    "answer": "节点流 (Node Stream)",
    "score": 3,
    "explanation": "节点流（如`FileInputStream`, `FileReader`）是I/O操作的起点，它们直接连接到物理数据源。处理流（如`BufferedInputStream`, `ObjectInputStream`）则包装在节点流之上，为其添加额外功能。"
  },
  {
    "id": 79,
    "type": "single",
    "question": "`File`类的`length()`方法返回的文件大小，其单位是什么？",
    "options": ["比特(bit)", "字节(byte)", "千字节(KB)", "字符数"],
    "answer": "字节(byte)",
    "score": 1.5,
    "explanation": "根据笔记中的API描述，`length()`方法返回的是`long`类型的字节数，这是文件大小在计算机系统中的基本单位。"
  },
  {
    "id": 80,
    "type": "short_answer",
    "question": "为什么Java I/O体系要设计成需要层层包装（如 `new BufferedReader(new FileReader(...))`）的结构？这种设计的核心优势是什么？",
    "answer": "这种设计是基于**装饰器设计模式**。其核心优势在于**灵活性和可组合性**。它将I/O的各种功能（如连接文件、提供缓冲、处理字符编码、序列化对象等）解耦到不同的类中。开发者可以根据具体需求，像搭积木一样自由地组合这些功能，为基础的节点流“装饰”上需要的能力，而无需为每一种功能组合都创建一个庞大而复杂的类。这大大提高了代码的复用性和扩展性。",
    "score": 4,
    "explanation": "这是一个宏观的设计思想问题，考察对Java I/O库设计哲学的理解，能够回答这个问题表明对I/O体系有了系统性的认识。"
  },
  {
    "id": 81,
    "type": "single",
    "question": "根据笔记，`Error`和`Exception`最核心的区别是什么？",
    "options": [
      "`Error`是编译期问题，`Exception`是运行期问题。",
      "`Error`由程序逻辑错误引起，而`Exception`由外部环境导致。",
      "`Error`是JVM层面的严重问题，程序通常无法处理和恢复；而`Exception`是可被程序捕获和处理的问题。",
      "`Error`必须使用`try-catch`处理，而`Exception`可以不处理。"
    ],
    "answer": "`Error`是JVM层面的严重问题，程序通常无法处理和恢复；而`Exception`是可被程序捕获和处理的问题。",
    "score": 2.5,
    "explanation": "这是对Java异常体系顶层设计的核心理解。`Error`代表了系统级的、灾难性的故障（如内存耗尽），超出了应用程序的处理能力范围，而`Exception`则是为程序健壮性设计，允许开发者通过编码来应对。"
  },
  {
    "id": 82,
    "type": "short_answer",
    "question": "请简述编译期异常（Checked Exception）和运行期异常（RuntimeException）之间的主要区别。",
    "answer": "主要区别在于编译器是否强制检查和处理。\n1. **编译期异常 (Checked Exception)**：编译器会强制要求程序员必须处理它，处理方式要么使用`try-catch`捕获，要么使用`throws`声明抛出，否则代码无法通过编译。它通常用于表示程序在与外部资源交互时可能发生的、不可避免的意外情况，如`IOException`。\n2. **运行期异常 (RuntimeException)**：编译器不强制要求处理。它通常是由程序自身的逻辑错误（如空指针、数组越界）引起的，理论上可以通过更严谨的代码来避免。",
    "score": 4,
    "explanation": "这是Java异常处理中一个极其重要的概念，也是面试中的高频问题。理解两者的区别，有助于编写出既健壮又清晰的代码。"
  },
  {
    "id": 83,
    "type": "multiple",
    "question": "根据笔记和Java规范，以下哪些异常属于运行期异常 (RuntimeException)？",
    "options": [
      "NullPointerException",
      "IOException",
      "ClassCastException",
      "SQLException"
    ],
    "answer": ["NullPointerException", "ClassCastException"],
    "score": 3,
    "explanation": "`NullPointerException`和`ClassCastException`都是`RuntimeException`的子类，通常由代码逻辑不严谨造成。而`IOException`和`SQLException`是典型的编译期异常，因为它们涉及与外部系统（文件、数据库）的交互，这些交互的成功与否在编译时是无法保证的。"
  },
  {
    "id": 84,
    "type": "single",
    "question": "在使用多个`catch`块捕获不同类型的异常时，正确的排列顺序是什么？",
    "options": [
      "父类异常在前，子类异常在后。",
      "子类异常在前，父类异常在后。",
      "顺序无所谓，JVM会自动匹配。",
      "必须按字母顺序排列。"
    ],
    "answer": "子类异常在前，父类异常在后。",
    "score": 3,
    "explanation": "因为Java的异常匹配机制是从上到下进行的。如果父类异常在前，它会捕获所有其子类的异常，导致后面的子类异常`catch`块永远无法被执行，这在编译时就会报错（unreachable code）。"
  },
  {
    "id": 85,
    "type": "code",
    "question": "分析以下代码的执行流程，它的最终输出结果是什么？\n\npublic int testFinally() {\n    int x = 1;\n    try {\n        x = 2;\n        System.out.println(10 / 0);\n        return x;\n    } catch (Exception e) {\n        x = 3;\n        return x;\n    } finally {\n        x = 4;\n    }\n}",
    "answer": "3",
    "score": 4.5,
    "explanation": "这是一个经典的面试题，用于考察`finally`块与`return`语句的交互。执行流程：\n1. `try`块中 `x` 变为 2。\n2. `10 / 0` 抛出`ArithmeticException`。\n3. `catch`块被执行，`x` 变为 3。\n4. `catch`块遇到`return x;`，它会先将返回值`3`暂存起来，准备返回。\n5. 在`return`之前，`finally`块必须执行，`x` 变为 4。\n6. `finally`块执行完毕后，`catch`块返回之前暂存的值，即`3`。`finally`块中对`x`的修改不会影响已经准备好的返回值。"
  },
  {
    "id": 86,
    "type": "short_answer",
    "question": "请解释`finally`代码块的作用以及它的执行时机。是否存在`finally`块不会被执行的特殊情况？",
    "answer": "`finally`块的作用是提供一个“无论如何都会执行”的代码区域，通常用于执行必须的清理工作，如关闭文件流、数据库连接、释放锁等资源，以避免资源泄漏。\n它的执行时机是：在`try-catch`结构执行完毕之后，无论`try`块是正常结束还是因异常中断，也无论`catch`块是否被执行，`finally`块总会执行。\n存在一种特殊情况`finally`不会执行：如果在`try`或`catch`块中调用了`System.exit()`方法来终止Java虚拟机，那么`finally`块将不会被执行。",
    "score": 3.5,
    "explanation": "考察对`finally`关键字的全面理解，包括其核心用途和执行的边界条件。"
  },
  {
    "id": 87,
    "type": "short_answer",
    "question": "请清晰地辨别`throw`和`throws`关键字在Java异常处理中的区别。",
    "answer": "`throw`和`throws`是两个完全不同的关键字：\n- **位置**：`throws`用在方法签名上，跟在参数列表后面；`throw`用在方法体内部。\n- **作用**：`throws`用于“声明”一个方法可能会抛出哪些类型的异常，是一种对调用者的契约或警告；`throw`是“抛出”一个具体的异常对象实例的动作。\n- **对象**：`throws`后面跟的是异常的类型（类名）；`throw`后面跟的是一个异常的对象实例（`new Exception()`）。\n- **总结**：`throws`是“说”可能会出问题，`throw`是“做”——真的把问题扔出来了。",
    "score": 4,
    "explanation": "这是异常处理部分的另一个经典面试题，准确区分这两个关键字的用法是掌握Java异常处理机制的基础。"
  },
  {
    "id": 88,
    "type": "multiple",
    "question": "关于`NullPointerException`，以下哪些说法是正确的？",
    "options": [
      "它是一种编译期异常，必须在编码时处理。",
      "当调用一个值为`null`的引用变量的成员方法或属性时，会发生此异常。",
      "避免此异常的最佳实践是在使用对象引用前进行非空判断（如`if (obj != null)`）。",
      "它通常由JVM内部错误引起，程序无法避免。"
    ],
    "answer": [
      "当调用一个值为`null`的引用变量的成员方法或属性时，会发生此异常。",
      "避免此异常的最佳实践是在使用对象引用前进行非空判断（如`if (obj != null)`）。"
    ],
    "score": 3,
    "explanation": "`NullPointerException`是最常见的运行时异常，由程序逻辑不严谨导致，完全可以通过防御性编程来避免。它不是编译期异常，也非JVM错误。"
  },
  {
    "id": 89,
    "type": "single",
    "question": "为了防止`ClassCastException`（类型转换异常）的发生，在进行强制类型转换之前，最推荐使用哪个关键字进行安全检查？",
    "options": ["typeof", "is_a", "instanceof", "checkcast"],
    "answer": "instanceof",
    "score": 2.5,
    "explanation": "`instanceof`是Java提供的用于检查一个对象是否是特定类或其子类的实例的关键字。`if (obj instanceof TargetType)`是进行安全类型转换的标准前置检查。"
  },
  {
    "id": 90,
    "type": "short_answer",
    "question": "在实际开发中，当Java内置的异常类型已经很丰富时，为什么我们还需要创建自定义异常？",
    "answer": "创建自定义异常主要有以下几个原因：\n1. **更精确地描述问题**：当内置异常不能准确、清晰地描述业务逻辑层面的特定错误时（如“用户名不存在”、“密码错误”、“余额不足”），自定义异常可以提供更强的可读性和可维护性。\n2. **实现统一的异常处理**：可以创建一个自定义的业务异常基类，所有具体的业务异常都继承自它。这样，在顶层调用处，可以通过捕获这个基类异常来统一处理所有预期的业务错误。\n3. **封装错误信息**：自定义异常可以携带更多的上下文信息（如错误码、详细描述、相关数据），而不仅仅是一个简单的错误消息，便于日志记录、问题排查和给前端返回结构化的错误信息。",
    "score": 4,
    "explanation": "这个问题考察的是软件设计的思想。创建自定义异常是构建健壮、可维护的企业级应用的重要实践，它将异常处理从纯粹的技术层面提升到了业务层面。"
  },
  {
    "id": 91,
    "type": "code",
    "question": "请创建一个表示“库存不足”的自定义运行时异常类`InsufficientStockException`，它应该继承自合适的父类，并提供一个接收错误消息的构造方法。",
    "answer": "public class InsufficientStockException extends RuntimeException {\n    public InsufficientStockException(String message) {\n        super(message);\n    }\n}",
    "score": 3,
    "explanation": "此题考察创建自定义异常的基本语法。选择继承`RuntimeException`表示这是一个在编码时可以被预见的逻辑问题，调用者无需强制捕获。提供一个调用`super(message)`的构造方法是标准实践。"
  },
  {
    "id": 92,
    "type": "single",
    "question": "如果在一个`try`块中执行了`System.exit(0);`，那么紧随其后的`finally`块会发生什么？",
    "options": [
      "会正常执行。",
      "不会被执行。",
      "会执行，但在执行完毕后程序不会终止。",
      "会抛出一个新的异常。"
    ],
    "answer": "不会被执行。",
    "score": 3.5,
    "explanation": "`System.exit(0);`的作用是立即终止当前运行的Java虚拟机。这是一个非常彻底的操作，一旦调用，整个JVM进程都会停止，因此`finally`块没有机会执行。"
  },
  {
    "id": 93,
    "type": "multiple",
    "question": "以下关于`throw`关键字的用法，哪些是正确的？",
    "options": [
      "可以`throw`一个`Error`对象。",
      "可以`throw`一个`Exception`对象。",
      "可以`throw`一个普通的Java对象（如`new String(\"error\")`）。",
      "`throw`语句会立即中断当前方法的执行。"
    ],
    "answer": [
      "可以`throw`一个`Error`对象。",
      "可以`throw`一个`Exception`对象。",
      "`throw`语句会立即中断当前方法的执行。"
    ],
    "score": 3,
    "explanation": "Java的`throw`关键字后面必须跟一个`Throwable`类（或其子类，即`Error`或`Exception`）的实例。不能抛出非`Throwable`类型的对象。一旦`throw`被执行，它会像`return`一样立即结束当前方法的执行，并将异常抛给调用栈的上层。"
  },
  {
    "id": 94,
    "type": "single",
    "question": "笔记中提到的`StackOverflowError`通常是由什么原因引起的？",
    "options": [
      "创建了过多的对象，导致堆内存耗尽。",
      "方法调用链过深，例如无限递归，导致栈内存耗尽。",
      "加载了过多的类，导致元空间耗尽。",
      "线程数量过多，无法再创建新线程。"
    ],
    "answer": "方法调用链过深，例如无限递归，导致栈内存耗尽。",
    "score": 2,
    "explanation": "每个线程都有一个独立的Java虚拟机栈，用于存储方法调用的栈帧。无限递归或过深的调用链会导致栈帧不断压栈而无法出栈，最终耗尽栈空间，引发`StackOverflowError`。"
  },
  {
    "id": 95,
    "type": "code",
    "question": "分析以下代码，调用`getValue()`方法的返回值是什么？\n\npublic int getValue() {\n    try {\n        return 1;\n    } finally {\n        return 2;\n    }\n}",
    "answer": "2",
    "score": 4.5,
    "explanation": "这也是一个关于`finally`和`return`的经典陷阱题。当`try`块和`finally`块都包含`return`语句时，`finally`块中的`return`会“覆盖”`try`（或`catch`）块中的`return`。`try`块的`return 1`会被准备好，但在真正返回之前，`finally`块执行，它的`return 2`会使得方法在此处直接返回，导致`try`块的返回值被丢弃。在IDE中，这种写法通常会收到一个“finally block does not complete normally”的警告，因为它是不推荐的编码风格。"
  },
  {
    "id": 96,
    "type": "short_answer",
    "question": "笔记中提到，应当通过“防御性编程”来主动避免常见的运行时异常。请解释什么是防御性编程，并以避免`ArrayIndexOutOfBoundsException`为例进行说明。",
    "answer": "防御性编程是一种编程思想，指在代码中主动预测并处理可能导致错误的各种边界条件和非法输入，从而使程序在面对意外情况时不会崩溃。\n以避免`ArrayIndexOutOfBoundsException`为例，防御性编程体现在：在访问一个数组的某个索引`i`之前，先进行判断，确保该索引是合法的。例如：\n`if (i >= 0 && i < array.length) { \n    // 索引合法，可以安全访问\n    value = array[i]; \n} else { \n    // 索引非法，进行错误处理，如打印日志、返回默认值等\n}`\n这样就主动避免了异常的发生。",
    "score": 3.5,
    "explanation": "考察对编程思想的理解和应用。防御性编程是编写高质量、健壮代码的核心技能之一。"
  },
  {
    "id": 97,
    "type": "single",
    "question": "如果一个方法A的签名是`public void methodA() throws IOException`，那么调用方法A的代码必须做什么？",
    "options": [
      "什么都不用做， protože `IOException`是运行时异常。",
      "必须使用`try-catch`块捕获`IOException`，或者在调用方法所在的方法签名上继续用`throws IOException`声明。",
      "只能使用`try-catch`块捕获，不能再向上抛出。",
      "必须在调用前手动关闭所有I/O资源。"
    ],
    "answer": "必须使用`try-catch`块捕获`IOException`，或者在调用方法所在的方法签名上继续用`throws IOException`声明。",
    "score": 3,
    "explanation": "`IOException`是编译期异常。`throws`关键字的作用就是将被声明的异常的处理责任转嫁给调用者。调用者有两种选择：要么就地处理（`try-catch`），要么继续“甩锅”（`throws`）。"
  },
  {
    "id": 98,
    "type": "multiple",
    "question": "在Java的异常体系中，以下关于`Throwable`类的说法哪些是正确的？",
    "options": [
      "它是所有`Error`和`Exception`的父类。",
      "可以直接`new Throwable()`并抛出。",
      "它包含了获取异常信息（如`getMessage()`）和堆栈跟踪（如`printStackTrace()`）的方法。",
      "它是一个抽象类，不能被实例化。"
    ],
    "answer": [
      "它是所有`Error`和`Exception`的父类。",
      "可以直接`new Throwable()`并抛出。",
      "它包含了获取异常信息（如`getMessage()`）和堆栈跟踪（如`printStackTrace()`）的方法。"
    ],
    "score": 3.5,
    "explanation": "`Throwable`是Java中所有可抛出问题的根类。它是一个具体的类，可以被实例化和抛出，尽管这样做通常没有`Error`或`Exception`那样语义明确。所有异常对象都从`Throwable`继承了`getMessage()`、`printStackTrace()`等核心方法。"
  },
  {
    "id": 99,
    "type": "code",
    "question": "根据笔记中的自定义异常示例，当执行`service.login(\"user\", \"123456\");`时，`main`方法的控制台会输出什么？\n\n(提示: `UserService`代码在笔记中)",
    "answer": "登录失败提示：账号不存在，请检查您的账号。",
    "score": 4,
    "explanation": "此题考察对自定义异常捕获流程的理解。当使用账号`\"user\"`调用`login`方法时，会触发`throw new AccountNotFoundException(\"账号不存在\");`。在`main`方法的`try-catch`结构中，这个异常会被第一个`catch (AccountNotFoundException e)`块精确捕获，因此会执行该块内的打印语句。"
  },
  {
    "id": 100,
    "type": "single",
    "question": "调用异常对象的`e.printStackTrace()`方法的主要作用是什么？",
    "options": [
      "向用户显示一个友好的错误信息。",
      "终止程序的运行。",
      "将异常的详细堆栈跟踪信息打印到标准错误流，主要用于程序员调试和问题定位。",
      "将异常信息记录到日志文件中。"
    ],
    "answer": "将异常的详细堆栈跟踪信息打印到标准错误流，主要用于程序员调试和问题定位。",
    "score": 2,
    "explanation": "`printStackTrace()`是开发和调试阶段排查问题的利器。它会展示异常的类型、消息以及从异常发生点到调用栈顶部的完整方法调用链，能帮助开发者快速定位代码中的问题所在。在生产环境中，通常会用更专业的日志框架来替代它。"
  },
  {
    "id": 101,
    "type": "short_answer",
    "question": "在创建自定义异常时，判断应该继承`Exception`还是`RuntimeException`的主要依据是什么？",
    "answer": "主要依据是异常所表示的错误的性质，以及你希望调用者如何处理它。\n- **继承`Exception` (创建编译期异常)**：如果这个异常代表的是调用者**无法预见和预防**的外部问题（如网络中断、文件损坏），或者是一种强制要求调用者必须关注并显式处理的业务流程。这会强制调用者使用`try-catch`或`throws`，提高了代码的健壮性。\n- **继承`RuntimeException` (创建运行期异常)**：如果这个异常代表的是一个**编程错误**或**API的误用**（如传递了非法参数），是调用者本应通过编写正确的代码来避免的。将其设为运行期异常可以避免代码中充斥着大量不必要的`try-catch`，使代码更简洁。",
    "score": 4,
    "explanation": "这是一个设计层面的问题，考察开发者对异常分类哲学思想的理解。正确的选择能极大地影响API的易用性和代码质量。"
  },
  {
    "id": 102,
    "type": "code",
    "question": "下面的`try-catch`代码块存在一个编译错误，请指出错误原因并修正它。\n\ntry {\n    // ... some code that might throw LoginException\n} catch (LoginException e) {\n    System.out.println(\"Login error\");\n} catch (AccountNotFoundException e) {\n    System.out.println(\"Account not found\");\n}",
    "answer": "错误原因：`AccountNotFoundException`是`LoginException`的子类。父类异常`LoginException`的`catch`块放在了子类异常的前面，导致子类异常的`catch`块永远无法被执行（unreachable code），从而产生编译错误。\n\n修正方法：将子类异常的`catch`块移到父类异常的前面。\n\ntry {\n    // ... some code\n} catch (AccountNotFoundException e) {\n    System.out.println(\"Account not found\");\n} catch (LoginException e) {\n    System.out.println(\"Login error\");\n}",
    "score": 3.5,
    "explanation": "此题是`catch`块顺序规则的实际应用。考察能否识别出异常类之间的继承关系，并应用正确的捕获顺序。"
  },
  {
    "id": 103,
    "type": "single",
    "question": "当执行`Integer.parseInt(\"abc\");`时，会抛出哪种具体的异常？",
    "options": [
      "IllegalArgumentException",
      "NumberFormatException",
      "ClassCastException",
      "ArithmeticException"
    ],
    "answer": "NumberFormatException",
    "score": 2,
    "explanation": "根据笔记，`NumberFormatException`专门用于表示“尝试将一个不符合数字格式的字符串转换为数字类型”时发生的错误。`\"abc\"`显然不是一个合法的整数格式。"
  },
  {
    "id": 104,
    "type": "multiple",
    "question": "关于Java中的`Error`，以下哪些描述是正确的？",
    "options": [
      "程序不应该尝试去捕获（catch）`Error`。",
      "`OutOfMemoryError`是 `Error`的一个典型例子。",
      "它继承自`Throwable`类。",
      "发生`Error`后，程序通常可以自我恢复并继续正常运行。"
    ],
    "answer": [
      "程序不应该尝试去捕获（catch）`Error`。",
      "`OutOfMemoryError`是 `Error`的一个典型例子。",
      "它继承自`Throwable`类。"
    ],
    "score": 3.5,
    "explanation": "`Error`表示的是JVM级别的、灾难性的失败，应用程序对此无能为力，尝试恢复几乎是不可能的，所以不应该捕获。它和`Exception`一样，都是`Throwable`的子类。"
  },
  {
    "id": 105,
    "type": "short_answer",
    "question": "在Java中，`try`、`catch`、`finally`这三个关键字有哪些合法的组合方式？请列举至少三种。",
    "answer": "合法的组合方式有：\n1. `try-catch`：用于捕获并处理异常，可以有多个`catch`块。\n2. `try-finally`：不捕获异常，但保证`finally`块中的资源清理代码总能执行。如果`try`中发生异常，异常会继续向上抛出。\n3. `try-catch-finally`：最完整的形式，既捕获处理异常，又保证资源能够被清理。\n\n注意：`try`块必须存在，`catch`和`finally`至少需要出现一个。`catch`和`finally`不能单独使用。",
    "score": 3,
    "explanation": "考察对异常处理语法结构的熟练掌握。理解`try-finally`这种组合在需要传递异常但又必须清理资源的场景下非常有用。"
  },
  {
    "id": 106,
    "type": "short_answer",
    "question": "请根据笔记，简述进程（Process）与线程（Thread）最核心的区别。",
    "answer": "最核心的区别在于资源分配和独立性。进程是操作系统资源分配的基本单位，拥有自己独立的内存空间，资源相互隔离。而线程是CPU调度的基本单位，是进程的一个执行单元，同一进程内的所有线程共享该进程的内存空间和资源。",
    "score": 3,
    "explanation": "这是并发编程的基石概念。理解进程是“资源容器”而线程是“执行路径”，是理解后续所有并发问题的基础。"
  },
  {
    "id": 107,
    "type": "single",
    "question": "根据笔记中的对比，为什么在Java中实现`Runnable`接口通常被认为是比继承`Thread`类更好的创建线程的方式？",
    "options": [
      "因为`Runnable`接口的`run()`方法可以有返回值。",
      "因为`Runnable`的写法更简单。",
      "因为它将任务（业务逻辑）与线程（执行机制）解耦，避免了Java单继承的限制，并且更便于多个线程共享同一份资源。",
      "因为通过`Runnable`创建的线程有更高的优先级。"
    ],
    "answer": "因为它将任务（业务逻辑）与线程（执行机制）解耦，避免了Java单继承的限制，并且更便于多个线程共享同一份资源。",
    "score": 3.5,
    "explanation": "这个问题考察了对两种线程创建方式优劣的深刻理解，这不仅仅是语法问题，更是软件设计原则（如单一职责、解耦）的体现。"
  },
  {
    "id": 108,
    "type": "short_answer",
    "question": "如果创建了一个`Thread`子类的实例`t1`，然后直接调用`t1.run()`方法而不是`t1.start()`方法，会发生什么？这与真正的多线程有何区别？",
    "answer": "如果直接调用`t1.run()`，并不会启动一个新的线程。`run()`方法会像一个普通的成员方法一样，在当前线程（例如`main`线程）中被同步执行。这与真正的多线程有本质区别：`start()`方法会向JVM请求创建一个新的线程，并由新线程来异步执行`run()`方法中的代码，从而实现并发；而直接调用`run()`只是一个普通的方法调用，整个过程仍然是单线程的串行执行。",
    "score": 4,
    "explanation": "这是初学者常犯的错误，也是一个经典的面试题。它深刻地考察了对线程启动机制的理解。`start()`是启动新线程的入口，而`run()`只是新线程要执行的任务体。"
  },
  {
    "id": 109,
    "type": "single",
    "question": "当一个`Thread`对象被创建，但在`start()`方法被调用之前，该线程处于生命周期中的哪个状态？",
    "options": ["RUNNABLE", "NEW", "BLOCKED", "TERMINATED"],
    "answer": "NEW",
    "score": 2,
    "explanation": "根据笔记中的线程生命周期定义，`new Thread()`之后，线程对象就已创建，但它只是一个普通的Java对象，尚未与操作系统线程关联，此时处于“新建 (NEW)”状态。"
  },
  {
    "id": 110,
    "type": "multiple",
    "question": "根据笔记，线程安全问题的发生需要满足哪些核心条件？",
    "options": [
      "存在多个线程并发执行。",
      "存在被多个线程共享的数据（共享资源）。",
      "至少有一个线程对共享数据执行了非原子性的修改操作。",
      "所有线程都必须处于`RUNNABLE`状态。"
    ],
    "answer": [
      "存在多个线程并发执行。",
      "存在被多个线程共享的数据（共享资源）。",
      "至少有一个线程对共享数据执行了非原子性的修改操作。"
    ],
    "score": 4,
    "explanation": "这三个选项是构成线程安全问题（数据竞争）的“三要素”，缺一不可。理解这三个核心诱因是分析和解决所有线程安全问题的前提。"
  },
  {
    "id": 111,
    "type": "multiple",
    "question": "关于`Object.wait()`和`Thread.sleep()`的深度辨析，以下哪些说法是正确的？",
    "options": [
      "`wait()`会释放线程持有的对象锁，而`sleep()`不会释放锁。",
      "`wait()`必须在`synchronized`代码块或方法中使用，而`sleep()`没有这个限制。",
      "`wait()`需要被其他线程通过`notify()`或`notifyAll()`唤醒，而`sleep()`在指定时间后会自动唤醒。",
      "`wait()`属于`Object`类的方法，而`sleep()`是`Thread`类的静态方法。"
    ],
    "answer": [
      "`wait()`会释放线程持有的对象锁，而`sleep()`不会释放锁。",
      "`wait()`必须在`synchronized`代码块或方法中使用，而`sleep()`没有这个限制。",
      "`wait()`需要被其他线程通过`notify()`或`notifyAll()`唤醒，而`sleep()`在指定时间后会自动唤醒。",
      "`wait()`属于`Object`类的方法，而`sleep()`是`Thread`类的静态方法。"
    ],
    "score": 5,
    "explanation": "这是一个极其重要的面试高频题，全面考察了`wait()`和`sleep()`在锁释放、使用环境、唤醒方式和所属类这四个核心维度的区别。掌握这些区别是理解Java线程协作与暂停机制的关键。"
  },
  {
    "id": 112,
    "type": "short_answer",
    "question": "为什么在现代并发编程实践中，强烈推荐使用线程池而不是手动`new Thread()`来管理线程？请至少说出两点核心优势。",
    "answer": "1. **降低资源消耗**：通过复用已存在的线程，避免了频繁创建和销毁线程带来的系统开销。\n2. **提高响应速度**：当任务到达时，可以直接从池中获取线程执行，无需等待线程创建的过程。\n3. **提高线程的可管理性**：线程池可以统一对线程进行分配、调优和监控，能够控制最大并发数，防止因无限制创建线程而耗尽系统资源导致服务崩溃。\n(回答任意两点即可)",
    "score": 3.5,
    "explanation": "考察对线程池核心价值的理解。在企业级开发中，直接`new Thread()`被认为是一种不规范的做法，使用线程池是并发编程的最佳实践。"
  },
  {
    "id": 113,
    "type": "code",
    "question": "请使用Java 8的Lambda表达式，创建一个新的线程并启动它，该线程的任务是在控制台打印出“Hello from Lambda Thread!”。",
    "answer": "new Thread(() -> {\n    System.out.println(\"Hello from Lambda Thread!\");\n}).start();",
    "score": 3,
    "explanation": "考察对`Runnable`接口作为函数式接口的理解，以及使用Lambda表达式简化匿名内部类的现代Java编程风格。"
  },
  {
    "id": 114,
    "type": "short_answer",
    "question": "在一个线程`main`中调用另一个线程`t1`的`t1.join()`方法，其确切含义是什么？哪个线程会进入等待状态？",
    "answer": "其确切含义是，让**当前正在执行的线程**（即`main`线程）进入等待状态，直到`t1`这个**目标线程**执行完毕（进入`TERMINATED`状态）。简单来说，就是`main`线程暂停下来，等待`t1`线程干完活儿再继续往下执行。",
    "score": 4,
    "explanation": "`join()`的调用主体和作用对象常常被混淆。此题精确考察了开发者是否清晰地知道是谁在等待谁，这是实现线程串行执行的关键。"
  },
  {
    "id": 115,
    "type": "single",
    "question": "`wait()`和`sleep()`在对待“锁”的问题上，最本质的区别是什么？",
    "options": [
      "`sleep()`需要锁，`wait()`不需要。",
      "`wait()`和`sleep()`都会释放锁。",
      "`sleep()`会持有锁进入休眠，而`wait()`会释放锁进入等待队列。",
      "`wait()`会释放所有锁，`sleep()`只释放部分锁。"
    ],
    "answer": "`sleep()`会持有锁进入休眠，而`wait()`会释放锁进入等待队列。",
    "score": 3.5,
    "explanation": "释放锁是`wait()`方法的核心机制，这使得其他线程有机会获得锁并执行，从而改变条件并最终唤醒等待的线程，这是实现线程间通信的基础。而`sleep()`只是单纯地让出CPU时间，并不影响锁的持有状态。"
  },
  {
    "id": 116,
    "type": "single",
    "question": "一个线程在尝试进入一个被其他线程持有的`synchronized`代码块时，会进入生命周期中的哪个状态？",
    "options": ["RUNNABLE", "WAITING", "BLOCKED", "TIMED_WAITING"],
    "answer": "BLOCKED",
    "score": 3,
    "explanation": "根据笔记，`BLOCKED`（阻塞）状态专门用于描述线程因等待获取`synchronized`的监视器锁（monitor lock）而被挂起的情况。"
  },
  {
    "id": 117,
    "type": "single",
    "question": "如果你需要一个能保证所有任务都按照提交顺序，一个接一个地串行执行的线程池，应该使用`Executors`的哪个工厂方法来创建？",
    "options": [
      "newFixedThreadPool(1)",
      "newCachedThreadPool()",
      "newSingleThreadExecutor()",
      "newScheduledThreadPool(1)"
    ],
    "answer": "newSingleThreadExecutor()",
    "score": 3,
    "explanation": "`newSingleThreadExecutor()`是专门为此场景设计的，它内部只有一个工作线程，并使用一个无界队列来存储任务，确保了任务的FIFO顺序执行。虽然`newFixedThreadPool(1)`效果类似，但`newSingleThreadExecutor`在语义上更清晰，并且能保证其内部的`ExecutorService`不会被重新配置以使用更多线程。"
  },
  {
    "id": 118,
    "type": "code",
    "question": "请补全以下代码，创建一个固定大小为5的线程池，并向其提交一个打印当前线程名的任务。",
    "answer": "import java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class ThreadPoolTask {\n    public static void main(String[] args) {\n        ExecutorService executorService = Executors.newFixedThreadPool(5);\n        executorService.submit(() -> {\n            System.out.println(\"Task executed by: \" + Thread.currentThread().getName());\n        });\n        executorService.shutdown();\n    }\n}",
    "score": 3.5,
    "explanation": "考察对`Executors`工厂方法和`ExecutorService.submit()`这两个核心API的熟练使用，这是线程池操作的基础。"
  },
  {
    "id": 119,
    "type": "multiple",
    "question": "关于`Thread.sleep()`方法的特性，以下哪些描述是正确的？",
    "options": [
      "它是一个静态方法，调用时会使当前执行的线程休眠。",
      "线程在`sleep`期间，不会释放它所持有的任何对象锁。",
      "调用`sleep`方法必须处理`InterruptedException`这个受检异常。",
      "它是一个实例方法，用于让指定的线程对象休眠。"
    ],
    "answer": [
      "它是一个静态方法，调用时会使当前执行的线程休眠。",
      "线程在`sleep`期间，不会释放它所持有的任何对象锁。",
      "调用`sleep`方法必须处理`InterruptedException`这个受检异常。"
    ],
    "score": 4,
    "explanation": "静态方法、不释放锁、需要处理`InterruptedException`是`Thread.sleep()`的三个关键特性。选项D是错误的，`sleep()`作用于“当前”线程，而不是指定的某个线程对象。"
  },
  {
    "id": 120,
    "type": "single",
    "question": "在需要多个线程处理同一份数据（如一个售票任务）的场景下，为何使用`implements Runnable`比`extends Thread`更具优势？",
    "options": [
      "因为`Runnable`性能更高。",
      "因为可以创建一个`Runnable`任务实例，并将其传递给多个`Thread`对象，从而让这些线程天然地共享该任务实例中的成员变量（数据）。",
      "因为`Thread`类不支持成员变量。",
      "因为`Runnable`可以避免线程安全问题。"
    ],
    "answer": "因为可以创建一个`Runnable`任务实例，并将其传递给多个`Thread`对象，从而让这些线程天然地共享该任务实例中的成员变量（数据）。",
    "score": 3.5,
    "explanation": "这直击了资源共享问题的核心。通过`Runnable`，数据和任务逻辑封装在一起，执行任务的线程可以分开创建，轻松实现“多个执行者，一个任务资源”的模式。"
  },
  {
    "id": 121,
    "type": "multiple",
    "question": "一个线程在执行了以下哪些方法后，会进入`TIMED_WAITING`（计时等待）状态？",
    "options": [
      "`Thread.sleep(500)`",
      "`object.wait(500)`",
      "`t.join(500)`",
      "`LockSupport.park()`"
    ],
    "answer": ["`Thread.sleep(500)`", "`object.wait(500)`", "`t.join(500)`"],
    "score": 3.5,
    "explanation": "带有超时参数的等待方法（如`sleep`, `wait(long)`, `join(long)`）都会使线程进入`TIMED_WAITING`状态。而没有参数的`wait()`、`join()`以及`LockSupport.park()`会使线程进入无限期的`WAITING`状态。"
  },
  {
    "id": 122,
    "type": "single",
    "question": "根据笔记，引入多线程技术的核心目的和价值在于什么？",
    "options": [
      "简化代码逻辑。",
      "提高程序的安全性。",
      "提高CPU的利用率，从而提升程序整体的执行效率。",
      "减少内存的使用。"
    ],
    "answer": "提高CPU的利用率，从而提升程序整体的执行效率。",
    "score": 2.5,
    "explanation": "笔记中明确指出，多线程的核心价值在于，当某个线程因I/O等原因阻塞时，CPU可以切换到其他线程，避免空闲，从而压榨CPU的性能，提升整个应用的吞吐量。"
  },
  {
    "id": 123,
    "type": "short_answer",
    "question": "在使用了线程池`ExecutorService`后，为什么通常建议在程序退出前调用`shutdown()`方法？它和`shutdownNow()`有什么主要区别？",
    "answer": "调用`shutdown()`是为了平滑地关闭线程池。它会阻止线程池接受任何新的任务，但会等待已经提交到队列中的所有任务执行完毕后，再关闭线程池并释放资源。\n主要区别：\n- `shutdown()`：温和关闭。不接受新任务，但会执行完已有的任务。\n- `shutdownNow()`：立即关闭。尝试中断所有正在执行的线程，并返回队列中尚未开始执行的任务列表，不会等待任务完成。",
    "score": 4,
    "explanation": "考察线程池的正确关闭方式。不关闭线程池会导致JVM无法正常退出，因为工作线程仍然存活。理解两种关闭方式的区别对于编写健壮的并发程序很重要。"
  },
  {
    "id": 124,
    "type": "single",
    "question": "`Object.wait()`方法必须在什么语境下调用，否则会抛出`IllegalMonitorStateException`？",
    "options": [
      "任何`try-catch`块中",
      "`synchronized`同步代码块或同步方法中",
      "任何静态方法中",
      "实现了`Runnable`接口的类的`run`方法中"
    ],
    "answer": "`synchronized`同步代码块或同步方法中",
    "score": 3,
    "explanation": "调用`wait()`、`notify()`、`notifyAll()`的前提是当前线程必须持有该对象的监视器锁（monitor lock）。`synchronized`关键字是获取这个锁的唯一方式，因此这些方法必须在同步块/方法中使用。"
  },
  {
    "id": 125,
    "type": "single",
    "question": "`Executors.newCachedThreadPool()`创建的线程池有什么样的核心特点？",
    "options": [
      "线程数量固定，适用于负载稳定的场景。",
      "只有一个线程，保证任务串行执行。",
      "线程数量根据任务量动态调整，几乎没有上限，适合执行大量、耗时短的任务。",
      "可以执行定时或周期性任务。"
    ],
    "answer": "线程数量根据任务量动态调整，几乎没有上限，适合执行大量、耗时短的任务。",
    "score": 3,
    "explanation": "可缓存线程池的特点是其高度的伸缩性。当有新任务时，如果池中有空闲线程就复用，如果没有就创建新线程，理论上可以无限创建。空闲超过一定时间（默认60秒）的线程会被回收。"
  }
]
