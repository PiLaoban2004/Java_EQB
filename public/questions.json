[
  {
    "id": 1,
    "type": "multiple",
    "question": "根据笔记内容，关于Java集合（Collection）与数组（Array）的对比，以下哪些说法是正确的？",
    "options": [
      "数组的长度是不可变的，而集合的长度是可变的。",
      "数组可以存储基本数据类型和引用数据类型，而集合只能存储引用数据类型。",
      "当处理一组数量在运行时可能动态变化的数据时，集合是比数组更好的选择。",
      "集合的底层数据结构只能是链表或哈希表，而数组是连续的内存空间。"
    ],
    "answer": [
      "数组的长度是不可变的，而集合的长度是可变的。",
      "数组可以存储基本数据类型和引用数据类型，而集合只能存储引用数据类型。",
      "当处理一组数量在运行时可能动态变化的数据时，集合是比数组更好的选择。"
    ],
    "score": 3,
    "explanation": "这是集合与数组最核心的区别。集合的底层数据结构是多样的，包括数组（如ArrayList）、链表（如LinkedList）、哈希表（如HashSet）、红黑树（如TreeSet）等，所以选项D是错误的。"
  },
  {
    "id": 2,
    "type": "single",
    "question": "在Java集合框架中，哪一个顶层接口用于表示键值对（Key-Value Pair）的集合？",
    "options": ["Collection", "List", "Set", "Map"],
    "answer": "Map",
    "score": 1,
    "explanation": "笔记中明确指出，Java集合框架分为两大顶层接口：`Collection`用于处理独立的、单个的元素；`Map`用于处理键值对数据。"
  },
  {
    "id": 3,
    "type": "short_answer",
    "question": "请简述`List`和`Set`接口在核心特性上的主要区别。",
    "answer": "`List`接口的特点是元素有序（按插入顺序存储）且可重复。`Set`接口的特点是元素通常无序（不保证插入顺序）且不可重复。",
    "score": 2.5,
    "explanation": "这是对`Collection`两大核心子接口基本特征的考察，理解它们的区别是选择正确集合类的第一步。"
  },
  {
    "id": 4,
    "type": "single",
    "question": "在何种业务场景下，使用`LinkedList`会比`ArrayList`具有明显的性能优势？",
    "options": [
      "需要频繁地根据索引随机访问集合中的元素。",
      "集合中绝大多数操作是遍历元素。",
      "需要频繁地在列表的头部和尾部进行插入和删除操作。",
      "集合创建后，元素数量固定不变，主要用于存储和读取。"
    ],
    "answer": "需要频繁地在列表的头部和尾部进行插入和删除操作。",
    "score": 3,
    "explanation": "根据笔记中的选型总结，`LinkedList`的底层是双向链表，对头尾节点的操作时间复杂度为O(1)，远优于`ArrayList`的O(n)。而随机访问是`ArrayList`的强项（O(1)）。"
  },
  {
    "id": 5,
    "type": "multiple",
    "question": "关于`ArrayList`的底层实现和特性，以下哪些说法是正确的？",
    "options": [
      "它的底层数据结构是动态数组。",
      "通过索引`get(index)`访问元素的时间复杂度为O(1)。",
      "在列表的中间位置插入或删除元素，其时间复杂度通常为O(n)。",
      "当容量不足时，`ArrayList`会自动扩容，创建一个更大的新数组并复制所有旧元素。"
    ],
    "answer": [
      "它的底层数据结构是动态数组。",
      "通过索引`get(index)`访问元素的时间复杂度为O(1)。",
      "在列表的中间位置插入或删除元素，其时间复杂度通常为O(n)。",
      "当容量不足时，`ArrayList`会自动扩容，创建一个更大的新数组并复制所有旧元素。"
    ],
    "score": 4,
    "explanation": "这四个选项全面地概括了`ArrayList`的核心工作原理和性能特点，这些都是Java开发中必须掌握的基础知识。"
  },
  {
    "id": 6,
    "type": "short_answer",
    "question": "为什么在创建 `ArrayList` 时，推荐指定一个预估的初始容量（如 `new ArrayList(100)`）？这样做有什么好处？",
    "answer": "推荐指定初始容量是为了性能优化。如果预先知道大致的数据量，指定初始容量可以避免或减少`ArrayList`在添加元素过程中因超出容量而触发的多次“扩容”操作。因为每次扩容都需要创建新数组并复制旧数组的全部元素，这是一个耗时的过程。",
    "score": 3,
    "explanation": "这是一个重要的性能优化技巧。在能预估数据量的场景下（例如，从数据库一次性查询N条记录放入List），指定初始容量是专业开发者的习惯。"
  },
  {
    "id": 7,
    "type": "code",
    "question": "请使用 `LinkedList` 的特有API，模拟一个栈（Stack）的入栈（push）和出栈（pop）操作。",
    "code_prompt": "LinkedList<String> stack = new LinkedList<>();",
    "answer": "// 入栈 \nstack.push(\"element1\"); \n// 或者 \nstack.addFirst(\"element1\"); \n\n// 出栈 \nString element = stack.pop(); \n// 或者 \nString element = stack.removeFirst();",
    "score": 3.5,
    "explanation": "笔记中提到`LinkedList`实现了`Deque`接口，因此提供了`push`和`pop`等方法，可以方便地作为栈使用。这考察了对`LinkedList`作为双端队列/栈使用的熟悉程度。"
  },
  {
    "id": 8,
    "type": "single",
    "question": "引入泛型（Generics）最主要的目标是什么？",
    "options": [
      "提升集合的运行效率。",
      "减少代码量。",
      "将类型检查从运行时提前到编译时，以提供类型安全。",
      "实现集合的多态性，让 `List<Dog>` 成为 `List<Animal>` 的子类。"
    ],
    "answer": "将类型检查从运行时提前到编译时，以提供类型安全。",
    "score": 2,
    "explanation": "泛型的核心价值在于类型安全。它允许编译器在编译阶段就发现类型不匹配的错误，避免了在运行时可能出现的`ClassCastException`，并免去了繁琐的手动类型转换。"
  },
  {
    "id": 9,
    "type": "short_answer",
    "question": "根据笔记，请解释为什么`List<User>`不是`List<Person>`的子类型，即使`User`是`Person`的子类？这个特性叫什么？",
    "answer": "这个特性叫做“泛型不具有多态性”。`List<User>`和`List<Person>`是两种完全不同的类型，它们之间没有继承关系。如果允许这种赋值（`List<Person> pList = new ArrayList<User>()`），那么之后就可以通过`pList.add(new Animal())`向一个本应只存放`User`的集合中添加其他类型的对象，这将破坏泛型的类型安全保证。",
    "score": 3.5,
    "explanation": "这是一个泛型中非常重要且容易混淆的概念。理解这一点对于正确使用泛型和理解泛型通配符（如`? extends Person`）至关重要。"
  },
  {
    "id": 10,
    "type": "multiple",
    "question": "要确保一个自定义类的对象能够在`HashSet`中正确地实现唯一性（即内容相同的对象被视为同一个），必须采取哪些措施？",
    "options": [
      "该类必须实现`Serializable`接口。",
      "该类必须重写`equals()`方法，定义对象内容相等的逻辑。",
      "该类必须重写`hashCode()`方法，并保证`equals()`为`true`的两个对象其`hashCode()`返回值也必须相等。",
      "该类必须实现`Comparable`接口。"
    ],
    "answer": [
      "该类必须重写`equals()`方法，定义对象内容相等的逻辑。",
      "该类必须重写`hashCode()`方法，并保证`equals()`为`true`的两个对象其`hashCode()`返回值也必须相等。"
    ],
    "score": 4,
    "explanation": "`HashSet`的唯一性判断依赖于`hashCode()`和`equals()`这两个方法。`hashCode()`用于快速定位存储位置，`equals()`用于在哈希冲突时进行精确比较。两者必须同时被正确重写，否则会导致集合行为异常。"
  },
  {
    "id": 11,
    "type": "short_answer",
    "question": "请简述当向一个`HashSet`中`add(element)`一个新元素时，其内部的详细工作流程。",
    "answer": "1. 首先调用`element`的`hashCode()`方法计算哈希码，通过哈希算法定位到底层`HashMap`中的一个桶（bucket）位置。\n2. 如果该桶为空，直接将元素存入，添加成功。\n3. 如果该桶不为空（发生哈希冲突），则遍历桶中的所有现有元素。\n4. 使用新元素`element`的`equals()`方法与桶内每个现有元素进行比较。\n5. 如果有任何一次`equals()`比较返回`true`，则认为元素已存在，添加失败。\n6. 如果遍历完所有元素，`equals()`都返回`false`，则将新元素添加到这个桶中（通常是链表或红黑树的末尾），添加成功。",
    "score": 4.5,
    "explanation": "这个问题深入考察了`HashSet`唯一性保证的底层原理，是Java面试中关于集合部分的高频考点，体现了对数据结构实现的深入理解。"
  },
  {
    "id": 12,
    "type": "single",
    "question": "根据笔记，`HashSet`的底层是使用哪一个集合类来实现其功能的？",
    "options": ["ArrayList", "TreeMap", "LinkedList", "HashMap"],
    "answer": "HashMap",
    "score": 2,
    "explanation": "笔记中明确指出，`HashSet`内部持有一个`HashMap`实例。添加到`HashSet`中的元素实际上是作为`key`存储在内部的`HashMap`中，而`value`则是一个固定的占位对象。"
  },
  {
    "id": 13,
    "type": "multiple",
    "question": "关于`HashMap`和`Hashtable`的对比，下列说法正确的有哪些？",
    "options": [
      "`HashMap`是非线程安全的，而`Hashtable`是线程安全的。",
      "`HashMap`允许一个null键和多个null值，而`Hashtable`不允许任何null键或null值。",
      "在新代码中，如果需要线程安全的Map，应优先选择`Hashtable`而不是`ConcurrentHashMap`。",
      "`HashMap`和`Hashtable`的默认初始容量和扩容机制完全相同。"
    ],
    "answer": [
      "`HashMap`是非线程安全的，而`Hashtable`是线程安全的。",
      "`HashMap`允许一个null键和多个null值，而`Hashtable`不允许任何null键或null值。"
    ],
    "score": 3.5,
    "explanation": "`Hashtable`是遗留的线程安全类，性能较差，现代并发编程推荐使用`ConcurrentHashMap`。`HashMap`和`Hashtable`的初始容量和扩容策略也不同。因此C和D是错误的。"
  },
  {
    "id": 14,
    "type": "single",
    "question": "在遍历一个`Map`集合时，哪种遍历方式被认为是最高效的，为什么？",
    "options": [
      "遍历`keySet()`，因为key是唯一的。",
      "遍历`values()`，因为直接获取值最快。",
      "遍历`entrySet()`，因为它可以一次性获取到key和value。",
      "使用迭代器遍历`keySet()`，因为迭代器最标准。"
    ],
    "answer": "遍历`entrySet()`，因为它可以一次性获取到key和value。",
    "score": 3,
    "explanation": "遍历`keySet()`后，还需要通过`map.get(key)`再次查找`value`，这在`HashMap`中涉及到一次额外的哈希定位。而遍历`entrySet()`，每个`Map.Entry`对象已经包含了`key`和`value`，无需二次查找，因此效率最高。"
  },
  {
    "id": 15,
    "type": "code",
    "question": "请补全以下代码，使用推荐的方式（`entrySet`）遍历一个`HashMap`并打印其所有键值对。",
    "code_prompt": "Map<Integer, String> map = new HashMap<>();\nmap.put(1, \"Java\");\nmap.put(2, \"Python\");",
    "answer": "Map<Integer, String> map = new HashMap<>();\nmap.put(1, \"Java\");\nmap.put(2, \"Python\");\n\nSet<Map.Entry<Integer, String>> entries = map.entrySet();\nfor (Map.Entry<Integer, String> entry : entries) {\n    System.out.println(entry.getKey() + \" -> \" + entry.getValue());\n}",
    "score": 3.5,
    "explanation": "考察对`Map`最高效遍历方式`entrySet`的实际编码能力，这是日常开发中的常用代码片段。"
  },
  {
    "id": 16,
    "type": "short_answer",
    "question": "什么是`ConcurrentModificationException`？在什么情况下会发生？",
    "answer": "`ConcurrentModificationException`（并发修改异常）是一个运行时异常。它通常发生在使用迭代器（包括增强for循环）遍历一个集合的过程中，同时又通过集合自身的方法（如`list.add()`, `map.remove()`）对集合的结构进行了修改（添加或删除元素）。",
    "score": 3.5,
    "explanation": "理解这个异常的触发条件是避免在集合遍历中踩坑的关键。根本原因在于迭代器维护的状态（如`expectedModCount`）与集合的实际状态（`modCount`）不一致了。"
  },
  {
    "id": 17,
    "type": "code",
    "question": "以下代码在运行时会抛出异常。请修改它，使其能够在遍历`List`时安全地删除所有包含\"bad\"的字符串。",
    "code_prompt": "List<String> list = new ArrayList<>(Arrays.asList(\"good\", \"bad\", \"nice\", \"bad idea\"));\nfor (String s : list) {\n    if (s.contains(\"bad\")) {\n        list.remove(s); \n    }\n}",
    "answer": "List<String> list = new ArrayList<>(Arrays.asList(\"good\", \"bad\", \"nice\", \"bad idea\"));\nIterator<String> iterator = list.iterator();\nwhile (iterator.hasNext()) {\n    String s = iterator.next();\n    if (s.contains(\"bad\")) {\n        iterator.remove(); // 使用迭代器的remove方法\n    }\n}",
    "score": 4,
    "explanation": "此题是`ConcurrentModificationException`的经典场景。正确做法是使用迭代器自身的`remove()`方法进行删除，因为该方法会同步集合和迭代器两者的内部状态，从而避免异常。"
  },
    {
    "id": 18,
    "type": "multiple",
    "question": "关于`Queue`接口中的`add`、`offer`、`put`三个用于插入元素的方法，以下描述正确的有哪些？",
    "options": [
      "`add(e)`在队列已满时会抛出`IllegalStateException`异常。",
      "`offer(e)`在队列已满时会返回`false`，而不会抛出异常。",
      "`put(e)`是`BlockingQueue`特有的方法，在队列已满时会阻塞当前线程，直到队列有空间。",
      "在任何情况下，这三个方法的行为都是完全一样的。"
    ],
    "answer": [
      "`add(e)`在队列已满时会抛出`IllegalStateException`异常。",
      "`offer(e)`在队列已满时会返回`false`，而不会抛出异常。",
      "`put(e)`是`BlockingQueue`特有的方法，在队列已满时会阻塞当前线程，直到队列有空间。"
    ],
    "score": 4,
    "explanation": "Queue接口为增删查操作提供了三套API，分别应对不同场景。`add`系列是“暴力派”，失败就抛异常；`offer`系列是“温柔派”，失败返回特殊值；`put`/`take`系列是“阻塞派”，专为并发场景设计。理解它们的区别对于编写健壮的程序至关重要。"
  },
  {
    "id": 19,
    "type": "multiple",
    "question": "与`Queue`的插入方法类似，其移除元素的`remove()`、`poll()`、`take()`方法也有不同行为。以下描述正确的有哪些？",
    "options": [
      "`remove()`在队列为空时会抛出`NoSuchElementException`异常。",
      "`poll()`在队列为空时会返回`null`。",
      "`take()`在队列为空时会阻塞线程，直到队列中有元素可取。",
      "对于非阻塞队列，`remove()`和`poll()`是完全等价的。"
    ],
    "answer": [
      "`remove()`在队列为空时会抛出`NoSuchElementException`异常。",
      "`poll()`在队列为空时会返回`null`。",
      "`take()`在队列为空时会阻塞线程，直到队列中有元素可取。"
    ],
    "score": 4,
    "explanation": "这考察了`Queue`三套API中用于移除元素的方法。在实际开发中，尤其是在高并发或需要处理边界条件的系统中，通常会选择使用`poll()`或`take()`来避免程序因异常而中断。"
  },
  {
    "id": 20,
    "type": "single",
    "question": "假设你正在开发一个生产者-消费者模型，使用`ArrayBlockingQueue`作为共享缓冲区。当缓冲区已满时，你希望生产者线程暂停等待，而不是抛出异常或立即返回失败。你应该使用哪个方法来放入元素？",
    "options": ["add(e)", "offer(e)", "put(e)", "push(e)"],
    "answer": "put(e)",
    "score": 3,
    "explanation": "根据笔记中对`ArrayBlockingQueue`的描述，`put(e)`方法正是在队列满时提供阻塞功能的API，这完全符合生产者-消费者模型中生产者需要等待的场景。"
  },
    {
    "id": 21,
    "type": "code",
    "question": "请编写一个`Comparator`，用于对一个`List<String>`按字符串长度进行降序排序。如果长度相同，则按字典序升序排序。",
    "code_prompt": "List<String> list = new ArrayList<>(Arrays.asList(\"apple\", \"banana\", \"pear\", \"kiwi\"));",
    "answer": "list.sort((s1, s2) -> {\n    if (s1.length() != s2.length()) {\n        return s2.length() - s1.length(); // 长度降序\n    } else {\n        return s1.compareTo(s2); // 字典序升序\n    }\n});",
    "score": 4.5,
    "explanation": "本题考察了`Comparator`接口的灵活运用，涉及两个排序维度（主、次排序条件），是实际开发中常见的自定义排序场景。使用Lambda表达式是现代Java的推荐写法。"
  },
  {
    "id": 22,
    "type": "single",
    "question": "在使用`Arrays.binarySearch()`方法进行二分查找前，对目标数组有什么样的前置要求？",
    "options": [
      "数组必须是`String`类型。",
      "数组必须已经排好序。",
      "数组长度必须是2的幂。",
      "数组不能包含重复元素。"
    ],
    "answer": "数组必须已经排好序。",
    "score": 2.5,
    "explanation": "二分查找算法的有效性建立在数据有序的基础上。如果在一个未排序的数组上执行`binarySearch`，其结果是未定义的，可能会返回错误的位置或找不到存在的元素。"
  },
  {
    "id": 23,
    "type": "single",
    "question": "调用`Map.put(K key, V value)`方法时，如果`key`在Map中已经存在，会发生什么？",
    "options": [
      "操作失败，抛出异常。",
      "操作失败，返回`false`。",
      "旧的`value`被新的`value`覆盖，方法返回新的`value`。",
      "旧的`value`被新的`value`覆盖，方法返回被覆盖的旧`value`。"
    ],
    "answer": "旧的`value`被新的`value`覆盖，方法返回被覆盖的旧`value`。",
    "score": 2,
    "explanation": "这是`Map.put`方法的一个重要特性。返回旧值使得调用者可以知道之前该key关联的值是什么，方便进行一些如“更新并记录旧值”的逻辑。"
  },
  {
    "id": 24,
    "type": "short_answer",
    "question": "在使用增强for循环（for-each loop）遍历一个List时，其底层实际上是如何工作的？为什么它同样会受到`ConcurrentModificationException`的影响？",
    "answer": "增强for循环在底层实际上是依赖`Iterator`（迭代器）工作的。编译器会将增强for循环代码转换为等效的使用`iterator()`方法获取迭代器，然后循环调用`hasNext()`和`next()`的代码。因为它本质上就是在使用迭代器，所以当在循环体内部通过集合自身的方法修改集合时，同样会触发`ConcurrentModificationException`。",
    "score": 3,
    "explanation": "理解增强for循环的语法糖本质有助于更深刻地理解Java的迭代机制和并发修改异常的根源。"
  },
  {
    "id": 25,
    "type": "single",
   "question": "如果一个自定义类只重写了`equals()`方法，而没有重写`hashCode()`方法，并将其对象作为元素添加到`HashSet`中，可能会导致什么问题？",
    "options": [
      "编译错误。",
      "运行时抛出`IllegalStateException`。",
      "两个内容相等（`equals`返回`true`）的对象可能都会被成功添加到`HashSet`中。",
      "性能下降，但功能完全正常。"
    ],
    "answer": "两个内容相等（`equals`返回`true`）的对象可能都会被成功添加到`HashSet`中。",
    "score": 4,
    "explanation": "如果没有重写`hashCode()`，它将使用从`Object`类继承的默认实现，该实现通常基于内存地址生成哈希码。因此，两个内容相同但内存地址不同的对象会有不同的哈希码，`HashSet`会将它们定位到不同的桶中，从而都添加成功，违背了`Set`的唯一性原则。"
  },
  {
    "id": 26,
    "type": "single",
    "question": "根据`Comparator<T>`接口的`compare(T o1, T o2)`方法的约定，如果要实现升序排序，当`o1`应该排在`o2`前面时，该方法应该返回什么？",
    "options": ["正整数", "负整数", "零", "true"],
    "answer": "负整数",
    "score": 3,
    "explanation": "这是`Comparator`接口的核心约定：返回负数意味着第一个参数`o1`“小于”第二个参数`o2`，应该排在前面；返回正数相反；返回零表示两者相等。"
  },
  {
    "id": 27,
    "type": "multiple",
    "question": "`LinkedList`实现了哪些重要的接口（根据笔记内容）？",
    "options": ["List", "Map", "Set", "Deque"],
    "answer": ["List", "Deque"],
    "score": 2,
    "explanation": "笔记中明确指出 `LinkedList` 是 `List` 接口的实现，同时它也实现了 `Deque` (双端队列) 接口，这使得它既有列表的特性，也具备队列和栈的能力。"
  },
  {
    "id": 28,
    "type": "short_answer",
    "question": "请描述`ArrayList`和`LinkedList`在内存开销上的主要区别。",
    "answer": "`ArrayList`的内存开销相对较小。它只需要存储元素本身，以及一些额外的容量信息。其内存是连续的。`LinkedList`的内存开销较大，因为它的每个元素都包装在一个节点（Node）对象中，该节点除了存储元素数据外，还需额外存储指向前一个和后一个节点的引用（指针），这增加了额外的内存占用。",
    "score": 3,
    "explanation": "在处理大量数据且内存敏感的场景下，内存开销是选择集合实现时需要考虑的一个因素。"
  },
  {
    "id": 29,
    "type": "single",
    "question": "执行`new ArrayList()`后，此时`ArrayList`的内部数组容量是多少？",
    "options": ["10", "16", "0", "1"],
    "answer": "0",
    "score": 2.5,
    "explanation": "根据笔记，JDK 7及以后的版本，`new ArrayList()`会创建一个初始容量为0的空列表（内部数组是一个空数组）。在第一次调用`add`方法时，才会进行第一次扩容，通常是分配一个容量为10的数组。"
  },
  {
    "id": 30,
    "type": "single",
    "question": "`map.values()`方法返回的是什么类型？",
    "options": ["List<V>", "Set<V>", "Collection<V>", "V[]"],
    "answer": "Collection<V>",
    "score": 2,
    "explanation": "`map.values()`返回一个`Collection`视图，因为它只保证包含了map中所有的值，但不保证顺序或唯一性（不同的key可以映射到相同的value）。因此，使用最泛化的`Collection`类型是合适的。"
  },
  {
    "id": 31,
    "type": "short_answer",
    "question": "为什么说遍历Map的`entrySet()`是最高效的方式？请从`HashMap`的实现角度解释。",
    "answer": "因为`HashMap`的`entrySet()`返回的`Set`中，每个`Entry`对象已经包含了键和值。遍历时，可以直接从`Entry`对象中获取`key`和`value`。相比之下，遍历`keySet()`时，在循环体内部需要通过`map.get(key)`来获取`value`，这个`get`操作需要根据`key`的哈希值再次进行一次查找定位过程。因此，遍历`entrySet()`避免了这次重复的查找，效率更高。",
    "score": 4,
    "explanation": "此题要求从`HashMap`的实现细节来解释性能差异，考察对`HashMap`工作原理的理解深度。"
  },
  {
    "id": 32,
    "type": "single",
    "question": "一个`HashMap`实例中，可以存在多少个`null`作为`key`？",
    "options": ["0个", "1个", "无限个", "不确定，取决于JDK版本"],
    "answer": "1个",
    "score": 2,
    "explanation": "笔记中明确提到，`HashMap`允许`key`和`value`为`null`。由于`key`必须是唯一的，所以最多只能有一个`key`为`null`。而`value`可以有多个为`null`。"
  },
  {
    "id": 33,
    "type": "code",
    "question": "给定一个`ArrayList<Integer> list`，请使用`list.sort()`方法和Lambda表达式对其进行降序排序。",
    "code_prompt": "ArrayList<Integer> list = new ArrayList<>(Arrays.asList(3, 1, 4, 1, 5, 9));",
    "answer": "list.sort((o1, o2) -> o2 - o1);",
    "score": 3,
    "explanation": "考察使用Lambda表达式快速实现`Comparator`接口，这是Java 8以后推荐的简洁写法。`o2 - o1`是实现Integer降序排序的经典技巧。"
  },
  {
    "id": 34,
    "type": "multiple",
    "question": "以下关于`Iterator`迭代器的说法，哪些是正确的？",
    "options": [
      "`Iterator`是遍历集合的统一标准接口。",
      "调用`next()`方法会返回下一个元素，并且会自动将内部指针后移。",
      "在通过迭代器遍历集合时，可以使用迭代器自身的`remove()`方法安全地删除元素。",
      "所有的`Collection`实现类都必须实现`Iterator`接口。"
    ],
    "answer": [
      "`Iterator`是遍历集合的统一标准接口。",
      "调用`next()`方法会返回下一个元素，并且会自动将内部指针后移。",
      "在通过迭代器遍历集合时，可以使用迭代器自身的`remove()`方法安全地删除元素。"
    ],
    "score": 3.5,
    "explanation": "选项D是错误的。`Collection`的实现类并未直接实现`Iterator`接口，而是提供了一个`iterator()`方法来返回一个`Iterator`的实例。其他三项都是对`Iterator`核心功能和用法的正确描述。"
  },
  {
    "id": 35,
    "type": "single",
    "question": "如果`HashMap`的key是一个自定义对象，那么这个对象必须满足什么条件才能保证`HashMap`的正常工作？",
    "options": [
      "必须实现`Comparable`接口。",
      "必须是不可变对象（Immutable）。",
      "必须正确地重写`hashCode()`和`equals()`方法。",
      "必须有一个无参构造函数。"
    ],
    "answer": "必须正确地重写`hashCode()`和`equals()`方法。",
    "score": 3,
    "explanation": "与`HashSet`一样，`HashMap`通过key的`hashCode()`和`equals()`来定位和区分不同的条目。为了确保能够正确地存取键值对，这两个方法必须被正确重写。虽然将不可变对象用作key是最佳实践，但不是强制要求。"
  },
  {
    "id": 36,
    "type": "single",
    "question": "在Java中，如果一个方法需要接收一个`List`，这个`List`中可以存放`Integer`或任何`Integer`的父类型（如`Number`, `Object`），那么该方法的参数类型应该如何声明？",
    "options": [
      "`List<Number> list`",
      "`List<? extends Number> list`",
      "`List<? super Integer> list`",
      "`List<Object> list`"
    ],
    "answer": "`List<? super Integer> list`",
    "score": 4.5,
    "explanation": "这是一个关于泛型通配符的进阶问题，虽然笔记中没有直接讲授通配符，但是基于“泛型不具有多态性”的概念延伸而来。`? super Integer`表示一个未知类型，这个类型是`Integer`本身或者其任何父类型，符合题意。这考察了对泛型更深层次的理解（PECS原则：Producer-Extends, Consumer-Super）。"
  },
  {
    "id": 37,
    "type": "short_answer",
    "question": "请解释`ArrayList`的`remove(int index)`和`remove(Object o)`两个重载方法之间的区别和潜在的陷阱。",
    "answer": "`remove(int index)`是按索引删除，它会删除指定位置的元素并返回被删除的元素。`remove(Object o)`是按内容删除，它会删除集合中与对象`o`相等的第一个元素，并返回一个布尔值（`true`表示删除成功）。潜在的陷阱是当`ArrayList`中存储的是`Integer`类型时，如果调用`list.remove(10)`，编译器会优先匹配`remove(int index)`，意图是删除索引为10的元素，而不是内容为10的元素。如果想按内容删除，必须传递一个`Integer`对象，如`list.remove(Integer.valueOf(10))`。",
    "score": 4,
    "explanation": "这个问题考察了对`ArrayList` API细节的掌握，特别是在处理`Integer`集合时由于自动装箱/拆箱可能引发的歧义和错误，非常具有实践性。"
  },
  {
    "id": 38,
    "type": "single",
    "question": "`Queue`接口遵循的基本原则是什么？",
    "options": ["后进先出 (LIFO)", "先进先出 (FIFO)", "无序", "按优先级"],
    "answer": "先进先出 (FIFO)",
    "score": 1.5,
    "explanation": "笔记中明确定义，Queue (队列) 是一种遵循先进先出 (FIFO, First-In-First-Out) 原则的特殊线性表。"
  },
  {
    "id": 39,
    "type": "single",
    "question": "以下哪个操作在`LinkedList`上的时间复杂度是O(n)？",
    "options": [
      "`addFirst(e)`",
      "`removeLast()`",
      "`get(int index)`",
      "`add(e)` (即 addLast)"
    ],
    "answer": "`get(int index)`",
    "score": 2.5,
    "explanation": "`LinkedList`由于是链表结构，无法直接通过计算内存地址偏移来访问元素，随机访问`get(index)`需要从头或尾开始遍历，直到找到第index个节点，所以时间复杂度是O(n)。而头尾操作都是O(1)。"
  },
  {
    "id": 40,
    "type": "short_answer",
    "question": "`Iterator`的`remove()`方法为什么是安全的，而集合的`remove()`方法在迭代时会不安全？请从`modCount`的角度解释。",
    "answer": "集合内部有一个`modCount`变量，记录集合结构被修改的次数。当创建迭代器时，迭代器会保存一份当前集合的`modCount`值（称为`expectedModCount`）。在迭代过程中，如果通过集合自身的`remove()`方法修改了集合，只会增加集合的`modCount`，而迭代器的`expectedModCount`没有变。下一次迭代器操作（如`next()`）会检查到`modCount != expectedModCount`，于是抛出`ConcurrentModificationException`。\n而`Iterator.remove()`方法是安全的，因为它在内部删除元素的同时，会主动更新迭代器自身的`expectedModCount`使其与集合的`modCount`保持同步，所以不会触发异常。",
    "score": 4.5,
    "explanation": "这是对并发修改异常底层机制的深度考察，能回答这个问题说明对`Iterator`的工作原理有非常清晰的认识。"
  },
  {
    "id": 41,
    "type": "multiple",
    "question": "`java.util.Arrays`工具类提供了哪些常用功能？",
    "options": [
      "`toString(array)`: 将数组转换为字符串。",
      "`sort(array)`: 对数组进行排序。",
      "`binarySearch(array, key)`: 在有序数组中进行二分查找。",
      "`toList(array)`: 直接将任何数组高效转换为`ArrayList`。"
    ],
    "answer": [
      "`toString(array)`: 将数组转换为字符串。",
      "`sort(array)`: 对数组进行排序。",
      "`binarySearch(array, key)`: 在有序数组中进行二分查找。"
    ],
    "score": 3,
    "explanation": "`Arrays`类没有`toList()`方法。将数组转为List通常使用`Arrays.asList()`，但它返回的是一个内部类的`List`，该`List`长度固定，不支持`add`或`remove`操作。所以选项D描述不准确。"
  },
  {
    "id": 42,
    "type": "single",
    "question": "对于一个已经存储了1000个元素的`ArrayList`，在列表的起始位置（索引0）插入一个新元素，大约需要执行多少次元素移动操作？",
    "options": ["1次", "2次", "1000次", "不需要移动"],
    "answer": "1000次",
    "score": 3,
    "explanation": "在`ArrayList`的起始位置插入元素，为了给新元素腾出空间，原有的所有1000个元素都需要向后移动一位。这是一个典型的O(n)操作，n是集合的大小。"
  },
  {
    "id": 43,
    "type": "single",
    "question": "以下哪种集合实现类在迭代时能保证元素的顺序与其插入时的顺序一致？",
    "options": ["HashSet", "HashMap", "ArrayList", "TreeSet"],
    "answer": "ArrayList",
    "score": 2,
    "explanation": "`ArrayList`和`LinkedList`都属于`List`，保证了元素的插入顺序。`HashSet`和`HashMap`是无序的。`TreeSet`和`TreeMap`会根据元素的自然顺序或指定的`Comparator`进行排序，而不是插入顺序。（注：`LinkedHashSet`和`LinkedHashMap`可以保证插入顺序，但笔记未提及）"
  },
  {
    "id": 44,
    "type": "code",
    "question": "如果有一个`User`类，包含`id`和`name`属性。请重写其`equals()`方法，使得只有当`id`和`name`都相同时，两个`User`对象才被认为是相等的。",
    "code_prompt": "class User {\n    private int id;\n    private String name;\n\n    // constructor, getters, setters...\n\n    @Override\n    public boolean equals(Object obj) {\n        // Your code here\n    }\n}",
    "answer": "@Override\npublic boolean equals(Object obj) {\n    if (this == obj) return true;\n    if (obj == null || getClass() != obj.getClass()) return false;\n    User otherUser = (User) obj;\n    return this.id == otherUser.id && java.util.Objects.equals(this.name, otherUser.name);\n}",
    "score": 3.5,
    "explanation": "考察`equals`方法的标准写法，包括地址比较、null检查和类型检查等前置判断。使用`Objects.equals()`来处理`name`可能为null的情况，是更健壮的写法。"
  },
  {
    "id": 45,
    "type": "short_answer",
    "question": "泛型中的“类型擦除”（Type Erasure）是什么意思？它对Java的泛型实现意味着什么？",
    "answer": "类型擦除是指Java泛型信息只存在于代码的编译阶段，在生成的字节码中，所有的泛型类型参数都会被替换为它们的上界（如`T`被替换为`Object`，`T extends Number`被替换为`Number`），并插入必要的类型转换代码。这意味着，对于JVM来说，`ArrayList<String>`和`ArrayList<Integer>`在运行时是同一个类（`ArrayList.class`），它并不知道集合中元素的确切泛型类型。",
    "score": 4,
    "explanation": "虽然笔记中只提到了泛型是编译期机制，但理解类型擦除是深入理解泛型本质的关键。这个问题考察了对这一核心概念的认知。"
  },
  {
    "id": 46,
    "type": "single",
    "question": "当不再推荐使用`Hashtable`时，如果需要一个线程安全的`Map`实现，应该优先选择哪个类？",
    "options": ["Collections.synchronizedMap(new HashMap())", "ConcurrentHashMap", "TreeMap", "自己用`synchronized`关键字包装HashMap的所有方法"],
    "answer": "ConcurrentHashMap",
    "score": 3,
    "explanation": "笔记中提到，`ConcurrentHashMap`提供了比`Hashtable`更好的并发性能。`ConcurrentHashMap`使用了更先进的锁机制（如分段锁或CAS），在高并发场景下，其吞吐量远超于对整个`Map`进行同步的`Hashtable`或`Collections.synchronizedMap`。"
  },
  {
    "id": 47,
    "type": "multiple",
    "question": "以下关于`HashSet`的说法，哪些是正确的？",
    "options": [
      "它不允许存储重复的元素。",
      "它通常不保证元素的存储和取出顺序。",
      "它允许存储一个`null`元素。",
      "它的所有操作都是线程安全的。"
    ],
    "answer": [
      "它不允许存储重复的元素。",
      "它通常不保证元素的存储和取出顺序。",
      "它允许存储一个`null`元素。"
    ],
    "score": 3,
    "explanation": "`HashSet`的核心特性就是无序、唯一，并允许一个null。与`HashMap`一样，它本身是非线程安全的。需要线程安全的Set可以使用`Collections.synchronizedSet()`或`ConcurrentHashMap.newKeySet()`。"
  },
  {
    "id": 48,
    "type": "single",
    "question": "如果一个`ArrayList`的`remove(Object o)`方法被调用，它会如何查找要删除的元素？",
    "options": [
      "使用二分查找。",
      "通过哈希定位。",
      "从头到尾依次遍历，使用`equals()`方法进行比较。",
      "从尾到头依次遍历，使用`==`进行比较。"
    ],
    "answer": "从头到尾依次遍历，使用`equals()`方法进行比较。",
    "score": 2.5,
    "explanation": "`ArrayList`的`remove(Object o)`实现是线性搜索，它会从列表的第一个元素开始，逐个调用`equals()`方法进行匹配，直到找到第一个匹配的元素并删除它。因此其时间复杂度是O(n)。"
  },
  {
    "id": 49,
    "type": "short_answer",
    "question": "在Java中，为何推荐使用接口（如`List`、`Map`）作为变量声明类型或方法参数类型，而不是具体的实现类（如 `ArrayList`、`HashMap`）？",
    "answer": "这是面向接口编程的一种体现，主要有以下好处：\n1. **解耦和灵活性**：代码不依赖于具体的实现细节。未来如果发现`ArrayList`性能不佳，可以很方便地将其替换为`LinkedList`或其他`List`实现，而不需要修改大量使用该`List`的代码。\n2. **可扩展性**：使代码更加通用，可以接受任何符合该接口规范的实现类的对象。\n3. **符合设计原则**：符合“依赖倒置原则”，即应该依赖于抽象，而不是依赖于具体。",
    "score": 3.5,
    "explanation": "这是一个非常重要的编程实践问题，考察了对面向对象设计原则的理解。例如，声明 `List<String> users = new ArrayList<>();` 好于 `ArrayList<String> users = new ArrayList<>();`。"
  },
  {
    "id": 50,
    "type": "code",
    "question": "假设有一个`Map<String, Integer> map`，其中一个键为\"b\"。以下这段删除操作的代码有什么问题？应该如何修正？",
    "code_prompt": "for (String key : map.keySet()) {\n    if (\"b\".equals(key)) {\n        map.remove(\"b\");\n    }\n}",
    "answer": "问题：这段代码会在运行时抛出`ConcurrentModificationException`，因为在通过`keySet`的迭代器进行遍历时，使用了`map`自身的方法`remove`来修改集合结构。\n\n修正：应该使用迭代器自身的`remove`方法进行删除。\n\nIterator<String> iterator = map.keySet().iterator();\nwhile (iterator.hasNext()) {\n    String key = iterator.next();\n    if (\"b\".equals(key)) {\n        iterator.remove(); // 正确做法\n    }\n}",
    "score": 4,
    "explanation": "这是并发修改异常的又一个经典案例，这次是发生在`Map`的遍历中。它强化了“在迭代过程中必须使用迭代器自己的方法来修改集合”这一黄金法则。"
  },
  {
    "id": 51,
    "type": "single",
    "question": "根据笔记，Java I/O将复杂的数据交换过程抽象为一种统一的模型，这个模型是什么？",
    "options": ["File", "Buffer", "Channel", "Stream"],
    "answer": "Stream",
    "score": 1.5,
    "explanation": "笔记开篇即明确指出，Java I/O的核心思想是将数据交换抽象为“流 (Stream)”，它是一种抽象的数据通道。"
  },
  {
    "id": 52,
    "type": "single",
    "question": "关于`java.io.File`类，以下哪个描述是最准确的？",
    "options": [
      "一个`File`对象包含了其所指向文件的实际数据内容。",
      "创建一个`new File(\"test.txt\")`对象会立即在磁盘上创建一个物理文件。",
      "`File`类是文件和目录路径名的抽象表示，是操作文件系统的入口。",
      "读写文件内容是`File`类的核心功能。"
    ],
    "answer": "`File`类是文件和目录路径名的抽象表示，是操作文件系统的入口。",
    "score": 2.5,
    "explanation": "笔记中重点强调了`File`类不等于文件内容，它仅仅是一个路径的代表。要读写内容，必须使用I/O流。创建`File`对象并不会创建物理文件，需要调用`createNewFile()`方法。"
  },
  {
    "id": 53,
    "type": "short_answer",
    "question": "请简述字节流和字符流的核心区别，并说明在何种场景下应该优先选择字符流？",
    "answer": "核心区别在于处理的数据单元不同：字节流以字节（byte）为单位，可以处理任何类型的数据；字符流以字符（char）为单位，专为处理文本数据设计。当需要处理纯文本文件（如.txt, .java, .properties, .xml）时，应该优先选择字符流，因为它可以自动处理字符编码，有效防止乱码问题。",
    "score": 3.5,
    "explanation": "这是对I/O流两大分支的根本性考察，理解它们的适用场景是正确使用Java I/O的基础。"
  },
  {
    "id": 54,
    "type": "single",
    "question": "从JDK 7开始，推荐使用`try-with-resources`语句来处理I/O流。其最主要的好处是什么？",
    "options": [
      "它能显著提高文件读写的性能。",
      "它能自动捕获并处理所有的`IOException`。",
      "它能保证流资源被自动、正确地关闭，无论是否发生异常，从而避免资源泄漏。",
      "它允许在单个`try`块中并发地读写多个文件。"
    ],
    "answer": "它能保证流资源被自动、正确地关闭，无论是否发生异常，从而避免资源泄漏。",
    "score": 3,
    "explanation": "笔记中明确指出，`try-with-resources`的核心价值在于自动资源管理，它极大地简化了代码并提高了程序的健壮性，避免了在复杂的`finally`块中手动关闭资源的麻烦和潜在错误。"
  },
  {
    "id": 55,
    "type": "short_answer",
    "question": "在使用字节数组作为缓冲区复制文件时，`out.write(buffer)`和`out.write(buffer, 0, len)`这两个写操作有何关键区别？为什么必须使用后者？",
    "answer": "关键区别在于写入的数据量。`out.write(buffer)`会写入整个缓冲区数组的内容，而`out.write(buffer, 0, len)`只写入缓冲区中从索引0开始的`len`个字节。必须使用后者是因为，在最后一次读取文件时，读入缓冲区的数据量（`len`）很可能小于缓冲区的总大小。如果此时仍使用`out.write(buffer)`，会将缓冲区中上一次读取后残留的“脏数据”也一并写入目标文件，导致文件末尾数据损坏。",
    "score": 4.5,
    "explanation": "这是一个非常深入且极具实践意义的问题，考察了对缓冲读写细节的深刻理解，是衡量开发者是否真正掌握文件I/O操作的标志性问题。"
  },
  {
    "id": 56,
    "type": "multiple",
    "question": "一个Java类的对象要想被成功序列化，必须满足以下哪些条件？",
    "options": [
      "该类必须实现`java.io.Serializable`接口。",
      "该类中所有非瞬态（non-transient）的成员变量也必须是可序列化的。",
      "该类必须提供一个公开的无参构造函数。",
      "该类的所有方法都必须是`public`的。"
    ],
    "answer": [
      "该类必须实现`java.io.Serializable`接口。",
      "该类中所有非瞬态（non-transient）的成员变量也必须是可序列化的。"
    ],
    "score": 4,
    "explanation": "序列化的基本要求是实现`Serializable`接口。此外，序列化是递归的，如果一个对象包含其他对象，这些被包含的对象（除非被`transient`修饰）也必须是可序列化的。无参构造函数是某些反序列化场景（如`Externalizable`）或框架的要求，但不是`Serializable`的强制要求。"
  },
  {
    "id": 57,
    "type": "single",
    "question": "在使用`BufferedReader`的`readLine()`方法读取文本文件时，该方法如何表示已到达文件末尾？",
    "options": ["返回-1", "返回一个空字符串(\"\")", "抛出`EOFException`", "返回`null`"],
    "answer": "返回`null`",
    "score": 2,
    "explanation": "笔记中的代码示例明确展示了`while ((line = reader.readLine()) != null)`的用法，这说明`readLine()`在读完所有行后会返回`null`。这与字节流的`read()`方法返回-1是不同的，需要区分记忆。"
  },
  {
    "id": 58,
    "type": "code",
    "question": "请补全代码，使用`try-with-resources`语句和缓冲流，实现一个将`source.txt`内容逐行复制到`dest.txt`的功能。",
    "code_prompt": "try (/* ... */) {\n    // ...\n} catch (IOException e) {\n    e.printStackTrace();\n}",
    "answer": "try (\n    BufferedReader reader = new BufferedReader(new FileReader(\"source.txt\"));\n    BufferedWriter writer = new BufferedWriter(new FileWriter(\"dest.txt\"))\n) {\n    String line;\n    while ((line = reader.readLine()) != null) {\n        writer.write(line);\n        writer.newLine(); // 写入换行符\n    }\n} catch (IOException e) {\n    e.printStackTrace();\n}",
    "score": 4,
    "explanation": "此题考察了字符缓冲流（`BufferedReader`, `BufferedWriter`）的典型用法，以及`try-with-resources`的正确格式。注意`readLine()`读取的内容不包含换行符，需要用`newLine()`或`write(\"\\n\")`手动添加。"
  },
  {
    "id": 59,
    "type": "single",
    "question": "如果你需要创建一个可能包含多级不存在父目录的目录结构，例如 `data/logs/app`，应该使用`File`类的哪个方法？",
    "options": ["create()", "mkdir()", "mkdirs()", "createNewFile()"],
    "answer": "mkdirs()",
    "score": 2.5,
    "explanation": "根据笔记API表格，`mkdir()`只能创建单级目录（父目录必须存在），而`mkdirs()`可以创建此路径对应的所有不存在的父目录，符合题意。"
  },
  {
    "id": 60,
    "type": "short_answer",
    "question": "在Java I/O中，`new BufferedInputStream(new FileInputStream(\"a.bin\"))`这种代码结构体现了哪种设计模式？请解释各个角色的对应关系。",
    "answer": "这种结构体现了**装饰器模式 (Decorator Pattern)**。\n- **抽象组件 (Component)**: `InputStream` 抽象类。\n- **具体组件 (Concrete Component)**: `FileInputStream`，它是被装饰的原始对象，负责与物理文件直接交互。\n- **装饰器 (Decorator)**: `BufferedInputStream`，它包装（装饰）了一个`InputStream`对象，并为其增加了缓冲功能以提升性能，同时它也继承自`InputStream`，保持了接口的统一。",
    "score": 4,
    "explanation": "将具体的I/O类库使用上升到设计模式的高度进行考察，体现了对软件设计原则的理解，属于中高难度题目。"
  },
  {
    "id": 61,
    "type": "multiple",
    "question": "以下哪些I/O相关的异常属于受检异常 (Checked Exception)？",
    "options": [
      "IOException",
      "FileNotFoundException",
      "NotSerializableException",
      "ArrayIndexOutOfBoundsException"
    ],
    "answer": ["IOException", "FileNotFoundException", "NotSerializableException"],
    "score": 3,
    "explanation": "`IOException`及其大部分子类（如`FileNotFoundException`, `NotSerializableException`）都属于受检异常，编译器会强制要求进行处理。而`ArrayIndexOutOfBoundsException`是`RuntimeException`的子类，属于非受检异常。"
  },
  {
    "id": 62,
    "type": "single",
    "question": "调用`File`对象的`delete()`方法试图删除一个目录时，什么情况下该操作会失败？",
    "options": [
      "目录是只读的。",
      "目录中包含了文件或子目录。",
      "程序没有管理员权限。",
      "以上所有情况都可能导致失败。"
    ],
    "answer": "以上所有情况都可能导致失败。",
    "score": 3,
    "explanation": "笔记中明确指出`delete()`只能删除**空**目录。此外，文件系统的权限（只读、操作系统权限）也是`delete`能否成功的现实因素。因此，这是一个综合性的考察。"
  },
  {
    "id": 63,
    "type": "code",
    "question": "请使用`File`类的API，编写代码来递归地删除一个非空目录及其所有内容。",
    "code_prompt": "public void deleteDirectory(File directory) {\n    // Your code here\n}",
    "answer": "public void deleteDirectory(File directory) {\n    File[] files = directory.listFiles();\n    if (files != null) {\n        for (File file : files) {\n            if (file.isDirectory()) {\n                deleteDirectory(file); // 递归删除子目录\n            } else {\n                file.delete(); // 删除子文件\n            }\n        }\n    }\n    directory.delete(); // 删除空目录本身\n}",
    "score": 4.5,
    "explanation": "这是一个经典的算法题，结合了`File`类的API（`listFiles`, `isDirectory`, `delete`）和递归思想，是面试中常见的文件操作考点。"
  },
  {
    "id": 64,
    "type": "short_answer",
    "question": "在进行对象反序列化时，除了`IOException`，为什么还必须捕获`ClassNotFoundException`？",
    "answer": "因为反序列化是将字节序列恢复为Java对象的过程，这个过程需要JVM根据字节流中的信息找到并加载对应的`.class`文件来构建对象。如果在当前的类路径（classpath）下找不到这个`.class`文件（例如，程序迁移后缺少了某个jar包，或者类名已更改），JVM就无法完成对象的重构，此时就会抛出`ClassNotFoundException`。",
    "score": 3.5,
    "explanation": "考察对反序列化底层机制的理解，即反序列化不仅仅是数据恢复，还依赖于运行时的类加载机制。"
  },
  {
    "id": 65,
    "type": "single",
    "question": "`FileInputStream`的`read()`方法返回一个`int`类型而不是`byte`类型，其主要目的是什么？",
    "options": [
      "为了兼容大于一个字节的宽字符。",
      "为了能够返回一个在合法字节值范围之外的特殊值（-1）来表示流的末尾。",
      "因为在早期的Java中，处理`int`比处理`byte`更快。",
      "这是一个历史遗留的API设计缺陷。"
    ],
    "answer": "为了能够返回一个在合法字节值范围之外的特殊值（-1）来表示流的末尾。",
    "score": 3,
    "explanation": "一个字节能表示的数值范围是0-255（无符号）。如果`read()`返回`byte`，那么任何返回值都可能是一个合法的数据字节，无法区分是数据还是结束信号。通过返回`int`，可以使用-1这个特殊值清晰地表示已到达流的末尾。"
  },
  {
    "id": 66,
    "type": "single",
    "question": "在处理I/O流时，`FileReader`、`FileInputStream` 这类流通常被称为“节点流”，而`BufferedReader`、`BufferedInputStream` 这类流被称为“处理流”。“节点流”最核心的特征是什么？",
    "options": [
      "它们性能最高。",
      "它们直接连接到具体的数据源或目的地（如文件、网络套接字）。",
      "它们内部自带缓冲区。",
      "它们只能处理字节数据。"
    ],
    "answer": "它们直接连接到具体的数据源或目的地（如文件、网络套接字）。",
    "score": 3.5,
    "explanation": "这是对I/O流装饰器模式中角色分工的理解。节点流是整个流链条的起点（输入）或终点（输出），是与物理设备直接打交道的“管道”，而处理流则是套在节点流之上的“增强设备”。"
  },
  {
    "id": 67,
    "type": "multiple",
    "question": "以下关于对象序列化的说法，哪些是正确的？",
    "options": [
      "序列化是将Java对象状态转换为字节序列的过程。",
      "只有实现了`Serializable`接口的类的对象才能被序列化。",
      "被`transient`关键字修饰的成员变量不会被序列化。",
      "静态（`static`）成员变量会被序列化到对象流中。"
    ],
    "answer": [
      "序列化是将Java对象状态转换为字节序列的过程。",
      "只有实现了`Serializable`接口的类的对象才能被序列化。",
      "被`transient`关键字修饰的成员变量不会被序列化。"
    ],
    "score": 4,
    "explanation": "选项D是错误的。序列化保存的是对象的状态（实例变量），而静态变量属于类级别，不属于任何特定对象的状态，因此不会被序列化。`transient`关键字的作用就是显式地排除某些实例变量，使其不参与序列化过程。"
  },
  {
    "id": 68,
    "type": "single",
    "question": "你正在编写一个程序，需要将一个包含多种数据类型（如`int`, `double`, `String`）的复杂对象持久化到磁盘。哪一对I/O流是完成此任务最直接和合适的选择？",
    "options": [
      "`FileWriter` 和 `FileReader`",
      "`FileOutputStream` 和 `FileInputStream`",
      "`ObjectOutputStream` 和 `ObjectInputStream`",
      "`PrintWriter` 和 `Scanner`"
    ],
    "answer": "`ObjectOutputStream` 和 `ObjectInputStream`",
    "score": 2.5,
    "explanation": "对象流（`ObjectOutputStream` / `ObjectInputStream`）是专门为序列化和反序列化整个Java对象而设计的，是处理复杂对象持久化的标准方式。"
  },
  {
    "id": 69,
    "type": "single",
    "question": "当`new FileOutputStream(file)`被成功调用后，如果`file`已经存在，将会发生什么？",
    "options": [
      "抛出`FileAlreadyExistsException`异常。",
      "在现有文件的末尾追加新内容。",
      "现有文件的内容将被清空（覆盖），准备写入新内容。",
      "询问用户是否要覆盖文件。"
    ],
    "answer": "现有文件的内容将被清空（覆盖），准备写入新内容。",
    "score": 3,
    "explanation": "`FileOutputStream`的这个构造函数默认以覆盖模式打开文件。如果希望追加内容，需要使用另一个构造函数 `new FileOutputStream(file, true)`。"
  },
  {
    "id": 70,
    "type": "short_answer",
    "question": "`Serializable`接口是一个没有任何方法的接口，它的作用是什么？这类接口在Java中被称为？",
    "answer": "这类接口被称为**标记接口 (Marker Interface)**。它的作用是向JVM提供一个元数据信息，即“标记”一个类的对象是“可以被序列化的”。JVM的序列化机制会在运行时检查一个对象所属的类是否实现了这个接口，以此来决定是否允许对其进行序列化操作。",
    "score": 3,
    "explanation": "考察对标记接口这一特殊设计模式的理解，以及`Serializable`接口在其中的具体作用。"
  },
  {
    "id": 71,
    "type": "multiple",
    "question": "调用`file.listFiles()`方法，在哪些情况下可能会返回`null`？",
    "options": [
      "当`file`对象代表的目录为空时。",
      "当`file`对象代表的路径不存在时。",
      "当`file`对象代表的路径是一个文件而不是一个目录时。",
      "当发生I/O错误（如权限不足）时。"
    ],
    "answer": [
      "当`file`对象代表的路径不存在时。",
      "当`file`对象代表的路径是一个文件而不是一个目录时。",
      "当发生I/O错误（如权限不足）时。"
    ],
    "score": 4,
    "explanation": "这是一个重要的API细节。当目录为空时，`listFiles()`会返回一个长度为0的空数组，而不是`null`。只有当`File`对象不代表一个有效的、可访问的目录时，才会返回`null`。"
  },
  {
    "id": 72,
    "type": "single",
    "question": "在性能方面，用`BufferedReader`包装`FileReader`，与用哪个类包装`FileInputStream`是出于同样的目的？",
    "options": [
      "`ObjectInputStream`",
      "`DataInputStream`",
      "`FilterInputStream`",
      "`BufferedInputStream`"
    ],
    "answer": "`BufferedInputStream`",
    "score": 2.5,
    "explanation": "`BufferedReader`为字符流提供缓冲，`BufferedInputStream`为字节流提供缓冲。它们的设计目的相同，都是通过减少对底层I/O设备的直接访问次数来提升读写性能，是装饰器模式在两个流体系中的平行应用。"
  },
  {
    "id": 73,
    "type": "short_answer",
    "question": "一个`User`类实现了`Serializable`接口，但你希望它的`password`字段不被序列化，应该如何操作？为什么通常要这样做？",
    "answer": "应该使用`transient`关键字修饰`password`字段，即 `private transient String password;`。通常这样做是出于**安全考虑**。密码、密钥等敏感信息不应该以明文形式持久化到文件或在网络上传输，以防止数据泄露后被恶意利用。将它们声明为`transient`可以有效避免其被包含在序列化的字节流中。",
    "score": 3.5,
    "explanation": "考察`transient`关键字的用法及应用场景，这在实际开发中处理敏感数据时非常重要。"
  },
  {
    "id": 74,
    "type": "single",
    "question": "当你需要向一个文本文件写入内容，并且希望代码在不同操作系统（如Windows和Linux）上都能正确生成换行，使用哪个类的哪个方法是最便捷和可移植的？",
    "options": [
      "`BufferedWriter`的`write(\"\\n\")`方法",
      "`FileWriter`的`write(System.lineSeparator())`方法",
      "`PrintWriter`的`println()`方法",
      "`FileOutputStream`的`write()`方法写入换行符的字节"
    ],
    "answer": "`PrintWriter`的`println()`方法",
    "score": 3,
    "explanation": "`PrintWriter.println()`方法会自动处理平台相关的行分隔符，提供了最佳的可移植性。其他选项虽然也能实现，但不如`println()`直接和方便。"
  },
  {
    "id": 75,
    "type": "multiple",
    "question": "以下哪些流属于字符流（Character Stream）？",
    "options": [
      "FileReader",
      "FileOutputStream",
      "PrintWriter",
      "BufferedInputStream"
    ],
    "answer": ["FileReader", "PrintWriter"],
    "score": 2,
    "explanation": "根据Java I/O的分类，以`Reader`或`Writer`结尾的类通常是字符流（如`FileReader`, `PrintWriter`）。以`InputStream`或`OutputStream`结尾的类是字节流（如`FileOutputStream`, `BufferedInputStream`）。"
  },
  {
    "id": 76,
    "type": "single",
    "question": "给定`File f = new File(\"../docs/report.pdf\");`，调用`f.getName()`会返回什么？",
    "options": ["../docs/report.pdf", "report.pdf", "docs/report.pdf", "../docs"],
    "answer": "report.pdf",
    "score": 2.5,
    "explanation": "`getName()`方法返回路径中最后一个名称分隔符之后的部分，即文件名或最内层的目录名，而不包括之前的路径信息。"
  },
  {
    "id": 77,
    "type": "code",
    "question": "假设一个文件`user.dat`中序列化存储了多个`User`对象。请补全代码，使用循环从文件中读取所有`User`对象，直到文件末尾。",
    "code_prompt": "List<User> users = new ArrayList<>();\ntry (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"user.dat\"))) {\n    // Your code here\n} catch (IOException | ClassNotFoundException e) {\n    e.printStackTrace();\n}",
    "answer": "List<User> users = new ArrayList<>();\ntry (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"user.dat\"))) {\n    while (true) {\n        try {\n            User user = (User) ois.readObject();\n            users.add(user);\n        } catch (EOFException e) {\n            // 到达文件末尾，正常退出循环\n            break;\n        }\n    }\n} catch (IOException | ClassNotFoundException e) {\n    e.printStackTrace();\n}",
    "score": 4.5,
    "explanation": "连续读取多个序列化对象的标准做法是使用一个无限循环，并在内部捕获`EOFException`（End Of File Exception），这个异常是`readObject()`在读到流末尾时抛出的，以此作为循环结束的标志。"
  },
  {
    "id": 78,
    "type": "single",
    "question": "在Java I/O的装饰器模式应用中，哪一类流是整个流“链条”的基础，直接与数据源（如文件）进行交互？",
    "options": ["节点流 (Node Stream)", "处理流 (Processing Stream)", "过滤流 (Filter Stream)", "对象流 (Object Stream)"],
    "answer": "节点流 (Node Stream)",
    "score": 3,
    "explanation": "节点流（如`FileInputStream`, `FileReader`）是I/O操作的起点，它们直接连接到物理数据源。处理流（如`BufferedInputStream`, `ObjectInputStream`）则包装在节点流之上，为其添加额外功能。"
  },
  {
    "id": 79,
    "type": "single",
    "question": "`File`类的`length()`方法返回的文件大小，其单位是什么？",
    "options": ["比特(bit)", "字节(byte)", "千字节(KB)", "字符数"],
    "answer": "字节(byte)",
    "score": 1.5,
    "explanation": "根据笔记中的API描述，`length()`方法返回的是`long`类型的字节数，这是文件大小在计算机系统中的基本单位。"
  },
  {
    "id": 80,
    "type": "short_answer",
    "question": "为什么Java I/O体系要设计成需要层层包装（如 `new BufferedReader(new FileReader(...))`）的结构？这种设计的核心优势是什么？",
    "answer": "这种设计是基于**装饰器设计模式**。其核心优势在于**灵活性和可组合性**。它将I/O的各种功能（如连接文件、提供缓冲、处理字符编码、序列化对象等）解耦到不同的类中。开发者可以根据具体需求，像搭积木一样自由地组合这些功能，为基础的节点流“装饰”上需要的能力，而无需为每一种功能组合都创建一个庞大而复杂的类。这大大提高了代码的复用性和扩展性。",
    "score": 4,
    "explanation": "这是一个宏观的设计思想问题，考察对Java I/O库设计哲学的理解，能够回答这个问题表明对I/O体系有了系统性的认识。"
  }
]
